<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sentry — Tests</title>
<style>
  :root { --bg: #0a0a0a; --text: #888; --text-strong: #ddd; --green: #4ade80; --red: #ff4b4b; --border: #222; --bg-alt: #151515; }
  body { background: var(--bg); color: var(--text); font-family: 'SF Mono', monospace; font-size: 14px; padding: 20px; max-width: 800px; margin: 0 auto; }
  h1 { color: var(--text-strong); font-size: 16px; font-weight: 500; margin-bottom: 16px; }
  .summary { margin-bottom: 20px; padding: 12px; background: var(--bg-alt); border: 1px solid var(--border); }
  .summary span { font-weight: 500; }
  .pass { color: var(--green); }
  .fail { color: var(--red); }
  .skip { color: #fbbf24; }
  .group { margin-bottom: 24px; }
  .group-title { color: var(--text-strong); font-weight: 500; margin-bottom: 8px; border-bottom: 1px solid var(--border); padding-bottom: 4px; }
  .test { padding: 4px 0; display: flex; gap: 8px; align-items: baseline; }
  .test .icon { flex-shrink: 0; width: 16px; }
  .test .name { flex: 1; }
  .test .time { color: var(--text); font-size: 12px; }
  .test .error { color: var(--red); font-size: 12px; margin-left: 24px; padding: 4px 0; }
  button { background: var(--text-strong); color: var(--bg); border: none; padding: 6px 16px; font-family: inherit; font-size: inherit; cursor: pointer; margin-bottom: 16px; }
  button:hover { opacity: 0.8; }
</style>
</head>
<body>
<h1>Sentry Test Suite</h1>
<button id="runBtn">Run all tests</button>
<div class="summary" id="summary">Waiting…</div>
<div id="results"></div>

<script type="module">
import * as config from './js/config.js';
import * as auth from './js/auth.js';
import * as api from './js/api.js';
import * as engine from './js/engine.js';

// ============================================================================
// TEST RUNNER
// ============================================================================

const groups = [];
let currentGroup = null;

function describe(name, fn) {
  currentGroup = { name, tests: [] };
  groups.push(currentGroup);
  fn();
  currentGroup = null;
}

function it(name, fn) {
  currentGroup.tests.push({ name, fn });
}

function assert(condition, message) {
  if (!condition) throw new Error(message || 'Assertion failed');
}

function assertEqual(actual, expected, label) {
  if (actual !== expected) throw new Error(`${label || 'Expected'} ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
}

function assertDeepEqual(actual, expected, label) {
  if (JSON.stringify(actual) !== JSON.stringify(expected)) {
    throw new Error(`${label || 'Expected'} ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
  }
}

async function runAll() {
  const resultsEl = document.getElementById('results');
  const summaryEl = document.getElementById('summary');
  resultsEl.innerHTML = '';
  let passed = 0, failed = 0, skipped = 0;
  const startAll = performance.now();

  for (const group of groups) {
    let groupHtml = `<div class="group"><div class="group-title">${group.name}</div>`;
    for (const test of group.tests) {
      const start = performance.now();
      try {
        await test.fn();
        const ms = (performance.now() - start).toFixed(1);
        groupHtml += `<div class="test"><span class="icon pass">✓</span><span class="name">${test.name}</span><span class="time">${ms}ms</span></div>`;
        passed++;
      } catch (e) {
        const ms = (performance.now() - start).toFixed(1);
        groupHtml += `<div class="test"><span class="icon fail">✕</span><span class="name">${test.name}</span><span class="time">${ms}ms</span></div>`;
        groupHtml += `<div class="error">${e.message}</div>`;
        failed++;
      }
    }
    groupHtml += '</div>';
    resultsEl.innerHTML += groupHtml;
  }

  const totalMs = (performance.now() - startAll).toFixed(0);
  summaryEl.innerHTML = `<span class="pass">${passed} passed</span> · <span class="${failed ? 'fail' : ''}">${failed} failed</span> · ${totalMs}ms`;
}

// ============================================================================
// TESTS: config.js
// ============================================================================

describe('config.js', () => {
  it('DEFAULT_PRESETS has 3 presets (tradfi, crypto, tech)', () => {
    assertEqual(config.DEFAULT_PRESETS.length, 3);
    assertEqual(config.DEFAULT_PRESETS[0].name, 'tradfi');
    assertEqual(config.DEFAULT_PRESETS[1].name, 'crypto');
    assertEqual(config.DEFAULT_PRESETS[2].name, 'tech');
  });

  it('RANGES has Today and Week only', () => {
    assertEqual(config.RANGES.length, 2);
    assertEqual(config.RANGES[0].label, 'Today');
    assertEqual(config.RANGES[1].label, 'Week');
  });

  it('calculateScanCredits computes correctly', () => {
    // 50 accounts × Today(1) × Sonnet(1) = 50
    assertEqual(config.calculateScanCredits(50, 1, 'claude-sonnet-4'), 50);
    // 50 accounts × Week(3) × Sonnet(1) = 150
    assertEqual(config.calculateScanCredits(50, 7, 'claude-sonnet-4'), 150);
    // 50 accounts × Today(1) × Haiku(0.25) = 13 (ceil)
    assertEqual(config.calculateScanCredits(50, 1, 'claude-haiku-3.5'), 13);
    // 10 accounts × Today(1) × Opus(5) = 50
    assertEqual(config.calculateScanCredits(10, 1, 'claude-opus-4'), 50);
  });

  it('CREDIT_PACKS has 4 packs with correct structure', () => {
    assertEqual(config.CREDIT_PACKS.length, 4);
    config.CREDIT_PACKS.forEach(p => {
      assert(p.id, 'Pack missing id');
      assert(p.name, 'Pack missing name');
      assert(p.credits > 0, 'Pack credits must be > 0');
      assert(p.price > 0, 'Pack price must be > 0');
    });
  });

  it('TV_SYMBOL_OVERRIDES has correct mappings', () => {
    assertEqual(config.TV_SYMBOL_OVERRIDES.HYPE, 'PYTH:HYPEUSD');
    assertEqual(config.TV_SYMBOL_OVERRIDES.XAU, 'TVC:GOLD');
    assertEqual(config.TV_SYMBOL_OVERRIDES.SPX, 'SP:SPX');
  });

  it('TICKER_SYMBOL_ALIASES has correct mappings', () => {
    assertEqual(config.TICKER_SYMBOL_ALIASES.RNDR, 'RENDER');
    assertEqual(config.TICKER_SYMBOL_ALIASES.AGIX, 'FET');
  });
});

// ============================================================================
// TESTS: engine.js — utilities
// ============================================================================

describe('engine.js — utilities', () => {
  it('hashString produces consistent hashes', () => {
    const h1 = engine.hashString('hello');
    const h2 = engine.hashString('hello');
    assertEqual(h1, h2);
    assert(engine.hashString('hello') !== engine.hashString('world'), 'Different inputs should produce different hashes');
  });

  it('sanitizeText removes control characters', () => {
    assertEqual(engine.sanitizeText('hello\x00world'), 'helloworld');
    assertEqual(engine.sanitizeText('test\x08ing'), 'testing');
    assertEqual(engine.sanitizeText('normal text'), 'normal text');
  });

  it('sanitizeText handles null/undefined', () => {
    assertEqual(engine.sanitizeText(null), '');
    assertEqual(engine.sanitizeText(undefined), '');
    assertEqual(engine.sanitizeText(''), '');
  });

  it('esc escapes HTML entities', () => {
    assertEqual(engine.esc('<script>'), '&lt;script&gt;');
    assertEqual(engine.esc('"test"'), '&quot;test&quot;');
    assertEqual(engine.esc('a & b'), 'a &amp; b');
  });

  it('normCat migrates old category names', () => {
    assertEqual(engine.normCat('Investment Idea'), 'Trade');
    assertEqual(engine.normCat('Tool / Product'), 'Tool');
    assertEqual(engine.normCat('Trade'), 'Trade');
    assertEqual(engine.normCat('Insight'), 'Insight');
  });
});

// ============================================================================
// TESTS: engine.js — TradingView symbols
// ============================================================================

describe('engine.js — TradingView symbols', () => {
  it('getTvSymbol uses override map for known symbols', () => {
    assertEqual(engine.getTvSymbol('HYPE'), 'PYTH:HYPEUSD');
    assertEqual(engine.getTvSymbol('XAU'), 'TVC:GOLD');
    assertEqual(engine.getTvSymbol('SPX'), 'SP:SPX');
  });

  it('getTvSymbol maps crypto to BINANCE format', () => {
    assertEqual(engine.getTvSymbol('BTC'), 'BINANCE:BTCUSDT');
    assertEqual(engine.getTvSymbol('ETH'), 'BINANCE:ETHUSDT');
    assertEqual(engine.getTvSymbol('SOL'), 'BINANCE:SOLUSDT');
  });

  it('getTvSymbol handles regional exchanges', () => {
    assert(engine.getTvSymbol('000660.KS').includes('KRX'), 'Korean stock should use KRX');
    assert(engine.getTvSymbol('2330.TW').includes('TWSE'), 'Taiwan stock should use TWSE');
  });

  it('getTvSymbol passes through regular US stocks', () => {
    assertEqual(engine.getTvSymbol('AAPL'), 'AAPL');
    assertEqual(engine.getTvSymbol('NVDA'), 'NVDA');
  });

  it('getTvSymbol strips dollar sign', () => {
    assertEqual(engine.getTvSymbol('$BTC'), 'BINANCE:BTCUSDT');
    assertEqual(engine.getTvSymbol('$AAPL'), 'AAPL');
  });
});

// ============================================================================
// TESTS: engine.js — signal normalization
// ============================================================================

describe('engine.js — signal normalization', () => {
  it('normalizeSignals handles empty/null input', () => {
    assertDeepEqual(engine.normalizeSignals(null), []);
    assertDeepEqual(engine.normalizeSignals([]), []);
    assertDeepEqual(engine.normalizeSignals(undefined), []);
  });

  it('normalizeSignals filters invalid signals', () => {
    const result = engine.normalizeSignals([
      { title: 'Valid', summary: 'test', category: 'Trade', tickers: [] },
      null,
      { title: '', summary: '' },
      { title: 'Also valid', summary: 'ok', category: 'Insight', tickers: [] },
    ]);
    assertEqual(result.length, 2);
  });

  it('normalizeSignals resolves ticker aliases', () => {
    const result = engine.normalizeSignals([
      { title: 'Test', summary: 'test', tickers: [{ symbol: '$RNDR', action: 'buy' }] },
    ]);
    assertEqual(result[0].tickers[0].symbol, '$RENDER');
  });

  it('normalizeSignals normalizes actions', () => {
    const result = engine.normalizeSignals([
      { title: 'Test', summary: 'test', tickers: [
        { symbol: '$BTC', action: 'BUY' },
        { symbol: '$ETH', action: 'unknown_action' },
        { symbol: '$SOL', action: null },
      ]},
    ]);
    assertEqual(result[0].tickers[0].action, 'buy');
    assertEqual(result[0].tickers[1].action, 'watch');
    assertEqual(result[0].tickers[2].action, 'watch');
  });

  it('normalizeSignals deduplicates tickers, merging to mixed', () => {
    const result = engine.normalizeSignals([
      { title: 'Test', summary: 'test', tickers: [
        { symbol: '$BTC', action: 'buy' },
        { symbol: '$BTC', action: 'sell' },
      ]},
    ]);
    assertEqual(result[0].tickers.length, 1);
    assertEqual(result[0].tickers[0].action, 'mixed');
  });

  it('normalizeSignals handles null ticker objects', () => {
    const result = engine.normalizeSignals([
      { title: 'Test', summary: 'test', tickers: [null, undefined, { symbol: '$BTC', action: 'buy' }] },
    ]);
    assertEqual(result[0].tickers.length, 1);
    assertEqual(result[0].tickers[0].symbol, '$BTC');
  });

  it('normalizeSignals migrates old categories', () => {
    const result = engine.normalizeSignals([
      { title: 'Test', summary: 'test', category: 'Investment Idea', tickers: [] },
    ]);
    assertEqual(result[0].category, 'Trade');
  });
});

// ============================================================================
// TESTS: engine.js — signal parsing
// ============================================================================

describe('engine.js — signal parsing', () => {
  it('safeParseSignals parses valid JSON array', () => {
    const result = engine.safeParseSignals('[{"title":"Test","summary":"ok"}]');
    assertEqual(result.length, 1);
    assertEqual(result[0].title, 'Test');
  });

  it('safeParseSignals handles markdown code blocks', () => {
    const result = engine.safeParseSignals('```json\n[{"title":"Test","summary":"ok"}]\n```');
    assertEqual(result.length, 1);
  });

  it('safeParseSignals returns empty for invalid input', () => {
    assertDeepEqual(engine.safeParseSignals(null), []);
    assertDeepEqual(engine.safeParseSignals(''), []);
    assertDeepEqual(engine.safeParseSignals('not json'), []);
  });

  it('safeParseSignals filters empty signals', () => {
    const result = engine.safeParseSignals('[{"title":"Good","summary":"ok"},{"title":"","summary":""}]');
    assertEqual(result.length, 1);
  });

  it('dedupeSignals removes duplicates by tweet_url', () => {
    const signals = [
      { title: 'A', tweet_url: 'https://x.com/1' },
      { title: 'B', tweet_url: 'https://x.com/1' },
      { title: 'C', tweet_url: 'https://x.com/2' },
    ];
    const result = engine.dedupeSignals(signals);
    assertEqual(result.length, 2);
  });
});

// ============================================================================
// TESTS: engine.js — schedule helpers
// ============================================================================

describe('engine.js — schedule helpers', () => {
  it('getBrowserTimezone returns a string', () => {
    const tz = engine.getBrowserTimezone();
    assert(typeof tz === 'string' && tz.length > 0, 'Should return non-empty timezone string');
  });

  it('formatScheduleTime formats correctly', () => {
    const result = engine.formatScheduleTime('14:30');
    assert(result.includes('2:30') || result.includes('14:30'), `Should format time, got: ${result}`);
  });

  it('formatScheduleTime handles invalid input', () => {
    assertEqual(engine.formatScheduleTime(null), '');
    assertEqual(engine.formatScheduleTime(''), '');
  });

  it('getNextScheduleTime returns null for empty schedules', () => {
    assertEqual(engine.getNextScheduleTime([]), null);
    assertEqual(engine.getNextScheduleTime(null), null);
  });

  it('getNextScheduleTime finds next enabled schedule', () => {
    const schedules = [
      { enabled: false, time: '08:00', days: [] },
      { enabled: true, time: '23:59', days: [] },
    ];
    const result = engine.getNextScheduleTime(schedules);
    assert(result !== null, 'Should find a schedule');
    assertEqual(result.schedule.time, '23:59');
  });
});

// ============================================================================
// TESTS: engine.js — sharing
// ============================================================================

describe('engine.js — sharing', () => {
  it('encodeSignal/decodeSignal round-trips correctly', () => {
    const signal = {
      title: 'BTC to 100k',
      summary: 'Moon mission',
      category: 'Trade',
      source: 'analyst1',
      tickers: [{ symbol: '$BTC', action: 'buy' }],
      tweet_url: 'https://x.com/test/1',
      links: ['https://example.com'],
    };
    const encoded = engine.encodeSignal(signal);
    const decoded = engine.decodeSignal(encoded);
    assertEqual(decoded.title, signal.title);
    assertEqual(decoded.summary, signal.summary);
    assertEqual(decoded.source, signal.source);
    assertEqual(decoded.tickers[0].symbol, '$BTC');
    assertEqual(decoded.links[0], 'https://example.com');
  });

  it('decodeSignal returns null for invalid input', () => {
    assertEqual(engine.decodeSignal('invalid'), null);
    assertEqual(engine.decodeSignal(''), null);
  });
});

// ============================================================================
// TESTS: engine.js — onboarding & settings
// ============================================================================

describe('engine.js — onboarding & settings', () => {
  it('isOnboardingDone returns boolean', () => {
    assert(typeof engine.isOnboardingDone() === 'boolean');
  });

  it('getShowTickerPrice defaults to true', () => {
    localStorage.removeItem('signal_show_ticker_price');
    assertEqual(engine.getShowTickerPrice(), true);
  });

  it('setShowTickerPrice/getShowTickerPrice round-trips', () => {
    engine.setShowTickerPrice(false);
    assertEqual(engine.getShowTickerPrice(), false);
    engine.setShowTickerPrice(true);
    assertEqual(engine.getShowTickerPrice(), true);
  });

  it('getIconSet defaults to sf', () => {
    localStorage.removeItem('signal_icon_set');
    assertEqual(engine.getIconSet(), 'sf');
  });
});

// ============================================================================
// TESTS: engine.js — analysis cache
// ============================================================================

describe('engine.js — analysis cache', () => {
  it('loadAnalysisCache returns valid structure', () => {
    const cache = engine.loadAnalysisCache();
    assert(cache.entries !== undefined, 'Cache should have entries');
  });

  it('getCachedSignals/setCachedSignals round-trips', () => {
    const cache = { v: 1, entries: {} };
    const signals = [{ title: 'Test', summary: 'ok' }];
    engine.setCachedSignals(cache, 'hash1', 'https://x.com/1', signals);
    const result = engine.getCachedSignals(cache, 'hash1', 'https://x.com/1');
    assertEqual(result.length, 1);
    assertEqual(result[0].title, 'Test');
  });

  it('getCachedSignals returns null for missing entries', () => {
    const cache = { v: 1, entries: {} };
    assertEqual(engine.getCachedSignals(cache, 'hash1', 'https://x.com/unknown'), null);
  });

  it('pruneCache removes old entries when over limit', () => {
    const cache = { v: 1, entries: {} };
    // Add entries with incrementing timestamps
    for (let i = 0; i < 10; i++) {
      cache.entries[`key${i}`] = { signals: [], ts: i };
    }
    // Manually set a small limit for testing (can't change MAX_CACHE_ENTRIES)
    // Just verify the function doesn't crash
    engine.pruneCache(cache);
    assert(Object.keys(cache.entries).length <= 2000, 'Cache should not exceed limit');
  });
});

// ============================================================================
// TESTS: auth.js — mock functions (dev mode guard)
// ============================================================================

describe('auth.js — mock functions', () => {
  it('_mockSignIn is guarded by ?dev param', () => {
    // On tests.html (no ?dev), mock should be a no-op
    const wasBefore = auth.isAuthenticated();
    auth._mockSignIn('test@test.com');
    // If we're not on ?dev, this should not change auth state
    // (unless tests.html has ?dev in URL)
    const isNow = auth.isAuthenticated();
    if (!window.location.search.includes('dev')) {
      assertEqual(isNow, wasBefore, 'Mock sign-in should be no-op without ?dev');
    }
  });

  it('isAuthenticated returns boolean', () => {
    assert(typeof auth.isAuthenticated() === 'boolean');
  });

  it('getToken returns string or null', () => {
    const token = auth.getToken();
    assert(token === null || typeof token === 'string');
  });
});

// ============================================================================
// TESTS: api.js — plan helpers
// ============================================================================

describe('api.js — plan helpers', () => {
  it('isBackendMode returns boolean', () => {
    assert(typeof api.isBackendMode() === 'boolean');
  });

  it('hasCredits returns false when not authenticated', () => {
    if (!auth.isAuthenticated()) {
      assertEqual(api.hasCredits(), false);
    }
  });

  it('getCreditsBalance returns number', () => {
    assert(typeof api.getCreditsBalance() === 'number');
  });

  it('isFreeScanAvailable returns boolean', () => {
    assert(typeof api.isFreeScanAvailable() === 'boolean');
  });

  it('_setMockProfile is guarded by ?dev param', () => {
    if (!window.location.search.includes('dev')) {
      const before = api.getCachedProfile();
      api._setMockProfile({ id: 'test', credits_balance: 999 });
      const after = api.getCachedProfile();
      assertEqual(after, before, 'Mock profile should be no-op without ?dev');
    }
  });
});

// ============================================================================
// TESTS: engine.js — price & ticker helpers
// ============================================================================

describe('engine.js — price & ticker helpers', () => {
  it('formatPrice handles various ranges', () => {
    assert(engine.formatPrice(50000).includes('50,000') || engine.formatPrice(50000).includes('50000'));
    assert(engine.formatPrice(1.23).includes('1.23'));
    assert(engine.formatPrice(0.005).length > 0);
  });

  it('formatChange includes sign', () => {
    assert(engine.formatChange(5.5).startsWith('+'));
    assert(engine.formatChange(-3.2).startsWith('-'));
  });

  it('isCrypto detects crypto symbols', () => {
    assertEqual(engine.isCrypto('BTC'), true);
    assertEqual(engine.isCrypto('$ETH'), true);
    assertEqual(engine.isCrypto('AAPL'), false);
  });

  it('normalizeSymbol maps indices', () => {
    assertEqual(engine.normalizeSymbol('SPX'), '^GSPC');
    assertEqual(engine.normalizeSymbol('VIX'), '^VIX');
    assertEqual(engine.normalizeSymbol('AAPL'), 'AAPL');
  });

  it('tickerUrl returns valid URL for various providers', () => {
    const url = engine.tickerUrl('$AAPL');
    assert(url.startsWith('http'), 'Should return a URL');
    assert(url.includes('AAPL'), 'Should contain the symbol');
  });
});

// ============================================================================
// RUN
// ============================================================================

document.getElementById('runBtn').addEventListener('click', runAll);

// Auto-run on load
runAll();
</script>
</body>
</html>
