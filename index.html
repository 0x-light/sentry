<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#0a0a0a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="description" content="AI-powered trading signal scanner. Extract actionable signals from Twitter accounts using Claude AI.">
<meta name="robots" content="index, follow">

<!-- Open Graph / Social -->
<meta property="og:type" content="website">
<meta property="og:title" content="Sentry — AI Trading Signal Scanner">
<meta property="og:description" content="Extract actionable trading signals from Twitter accounts using Claude AI. Scan multiple accounts, filter by category, and export your findings.">
<meta property="og:image" content="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 630'><rect fill='%23ffffff' width='1200' height='630'/><rect x='555' y='220' width='90' height='90' fill='%230a0a0a'/><text x='600' y='420' font-size='60' font-family='system-ui' text-anchor='middle' fill='%23333'>Sentry</text></svg>">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Sentry — AI Trading Signal Scanner">
<meta name="twitter:description" content="Extract actionable trading signals from Twitter using Claude AI.">

<title>sentry</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23ffffff' width='100' height='100' rx='16'/><rect x='35' y='35' width='30' height='30' fill='%230a0a0a'/></svg>">
<link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23ffffff' width='100' height='100' rx='20'/><rect x='35' y='35' width='30' height='30' fill='%230a0a0a'/></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #ffffff; --bg-alt: #f5f5f5; --text: #555; --text-strong: #222; --text-strong-rgb: 34,34,34; --text-muted: #999;
  --text-10: rgba(85,85,85,0.1); --text-20: rgba(85,85,85,0.2);
  --border: #eee; --border-light: #f5f5f5; --chip-bg: transparent; --chip-border: #ddd;
  --green: #1a7a1a; --green-10: rgba(26,122,26,0.1);
  --red: #cc2222; --red-10: rgba(204,34,34,0.1);
  --blue: #2255bb; --blue-10: rgba(34,85,187,0.1);
  --purple: #7733aa; --purple-10: rgba(119,51,170,0.1);
  --amber: #996600; --amber-10: rgba(153,102,0,0.1);
  /* Font sizes */
  --fs: 14px; --fs-sm: 14px; --fs-xs: 14px; --fs-lg: 14px; --fs-xl: 14px;
}
[data-font-size="xsmall"] { --fs: 12px; --fs-sm: 12px; --fs-xs: 12px; --fs-lg: 12px; --fs-xl: 12px; }
[data-font-size="small"] { --fs: 13px; --fs-sm: 13px; --fs-xs: 13px; --fs-lg: 13px; --fs-xl: 13px; }
[data-font-size="large"] { --fs: 15px; --fs-sm: 15px; --fs-xs: 15px; --fs-lg: 15px; --fs-xl: 15px; }
[data-font-size="xlarge"] { --fs: 17px; --fs-sm: 17px; --fs-xs: 17px; --fs-lg: 17px; --fs-xl: 17px; }
[data-theme="dark"] {
  --bg: #0a0a0a; --bg-alt: #151515; --text: #888; --text-strong: #ddd; --text-strong-rgb: 221,221,221; --text-muted: #555;
  --text-10: rgba(136,136,136,0.1); --text-20: rgba(136,136,136,0.2);
  --border: #222; --border-light: #1a1a1a; --chip-bg: #151515; --chip-border: #333;
  --green: #4ade80; --green-10: rgba(74,222,128,0.1);
  --red: #ff4b4b; --red-10: rgba(248,113,113,0.1);
  --blue: #60a5fa; --blue-10: rgba(96,165,250,0.1);
  --purple: #a78bfa; --purple-10: rgba(167,139,250,0.1);
  --amber: #fbbf24; --amber-10: rgba(251,191,36,0.1);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* minimal scrollbars */
::-webkit-scrollbar { width: 1px; height: 1px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--text-muted); }
::-webkit-scrollbar-thumb:hover { background: var(--text); }
* { scrollbar-width: thin; scrollbar-color: var(--text-muted) transparent; }

body {
  background: var(--bg); color: var(--text);
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: var(--fs); -webkit-font-smoothing: antialiased;
}
[data-font="system"], [data-font="system"] * {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
/* Text case - default is lowercase */
/* Lowercase mode - UI elements only */
[data-case="lower"] .logo-text, [data-case="lower"] .top-btn, [data-case="lower"] .add-btn,
[data-case="lower"] .preset-chip, [data-case="lower"] .preset-manage, [data-case="lower"] .sug,
[data-case="lower"] .rng, [data-case="lower"] .clear-btn,
[data-case="lower"] .scan-btn, [data-case="lower"] .cancel-btn, [data-case="lower"] .sig-cat,
[data-case="lower"] .dl-btn, [data-case="lower"] .footer,
[data-case="lower"] .empty-state, [data-case="lower"] .see-post, [data-case="lower"] .modal h3,
[data-case="lower"] .modal label, [data-case="lower"] .modal-sm-btn, [data-case="lower"] #cacheSize,
[data-case="lower"] .modal-actions button, [data-case="lower"] .preset-list-item button,
[data-case="lower"] input::placeholder, [data-case="lower"] textarea::placeholder { text-transform: lowercase; }
::selection { background: var(--bg-alt); color: var(--green); }
input::placeholder { color: var(--text-muted); }
button { font-family: inherit; cursor: pointer; }

.topbar {
  padding: 10px 20px; border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
}
.logo { display: flex; align-items: center; gap: 8px; }
.dot { font-size: var(--fs); color: var(--text-strong); line-height: 1; }
.dot.loading { animation: pulse 0.6s infinite; }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
.logo-text { font-size: var(--fs); font-weight: 500; color: var(--text-strong); }
.topbar-right { display: flex; align-items: center; gap: 8px; }
.top-btn { background: none; border: none; font-size: var(--fs); color: var(--text-muted); }
.top-btn:hover { color: var(--text); }
.top-btn.warn { color: var(--amber); }

/* modal */
.modal-bg {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,.5); z-index: 100;
  align-items: center; justify-content: center; padding: 16px;
}
.modal-bg.open { display: flex; }
.modal {
  background: var(--bg); border: 1px solid var(--border);
  padding: 24px; width: 100%; max-width: 600px; max-height: calc(100vh - 32px); overflow-y: auto;
  position: relative;
}
.modal-close { position: absolute; top: 16px; right: 16px; background: none; border: none; color: var(--text-muted); font-size: var(--fs); cursor: pointer; padding: 4px 8px; line-height: 1; }
.modal-close:hover { color: var(--text-strong); }
.modal h3 { font-size: var(--fs-xl); font-weight: 500; color: var(--text-strong); margin-bottom: 8px; }
.modal p { font-size: var(--fs); color: var(--text-muted); margin-bottom: 24px; line-height: 1.6; }
.modal p a { color: var(--blue); text-decoration: none; }
.modal p a:hover { text-decoration: underline; }
.modal label { display: block; font-size: var(--fs-sm); color: var(--text-muted); margin-bottom: 6px; margin-top: 16px; text-transform: uppercase; }
.modal label:first-of-type { margin-top: 0; }
.reset-prompt { background: none; border: none; color: var(--text-muted); font-size: var(--fs-sm); cursor: pointer; margin-left: 8px; text-transform: lowercase; }
.reset-prompt:hover { color: var(--text-strong); }
.modal input, .modal select, .modal textarea {
  width: 100%; border: 1px solid var(--chip-border); padding: 10px 12px;
  font-family: inherit; font-size: inherit; color: var(--text-strong); outline: none;
  background: var(--bg); resize: vertical;
}
.modal select {
  padding-right: 36px; cursor: pointer;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
}
[data-theme="dark"] .modal select {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23999' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
}
.modal input:focus, .modal textarea:focus { border-color: var(--text-muted); }
.modal-actions { display: flex; gap: 8px; margin-top: 24px; justify-content: flex-end; }
.modal-actions button {
  background: none; border: 1px solid var(--chip-border);
  font-size: var(--fs); padding: 3px 6px; color: var(--text);
}
.modal-actions button:hover { border-color: var(--text-muted); color: var(--text-strong); }
.modal-actions button:last-child { background: var(--text-strong); border-color: var(--text-strong); color: var(--bg); }
.modal-actions button:last-child:hover { opacity: 0.9; }
.modal-actions button.danger { color: var(--red); margin-right: auto; }
.modal-actions button.danger:hover { border-color: var(--red); }
.modal-sm-btn { background: none; border: 1px solid var(--chip-border); font-size: var(--fs); padding: 3px 6px; color: var(--text); cursor: pointer; }
.modal-sm-btn:hover { border-color: var(--text-muted); color: var(--text-strong); }
.preset-list { margin-top: 24px; border-top: 1px solid var(--border); padding-top: 16px; }
.preset-list-item {
  display: flex; align-items: center; justify-content: space-between; padding: 10px 0;
  border-bottom: 1px solid var(--border-light); font-size: var(--fs);
}
.preset-list-item:last-child { border-bottom: none; }
.preset-list-item span { color: var(--text-strong); }
.preset-list-item small { color: var(--text-muted); margin-left: 8px; font-size: var(--fs-sm); }
.preset-list-item.editing { background: var(--bg-alt); margin: 0 -8px; padding: 10px 8px; }
.preset-list-actions { display: flex; gap: 8px; }
.preset-list-item button { background: none; border: none; color: var(--text-muted); font-size: var(--fs-sm); padding: 4px 0; }
.preset-list-item button:hover { color: var(--text-strong); }
.preset-list-item button.danger:hover { color: var(--red); }

.controls { padding: 20px; border-bottom: 1px solid var(--border); }
.input-row { display: flex; gap: 6px; align-items: center; margin-bottom: 20px; }
.input-row .at { color: var(--text-muted); font-size: var(--fs); }
.input-row input {
  flex: 1; background: transparent; border: none; outline: none;
  color: var(--text-strong); font-size: inherit; font-family: inherit;
}
.add-btn { background: none; border: none; color: var(--text-muted); font-size: var(--fs); padding: 3px 6px; display: none; }
.add-btn.vis { display: inline; }

.presets-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 20px; }
.preset-chip {
  background: var(--text-10); border: none;
  color: var(--text-muted); font-size: var(--fs);
  display: inline-flex; align-items: center; gap: 5px; cursor: pointer;
}
.preset-chip:hover { color: var(--text-strong); }
.preset-chip.selected { color: var(--bg-alt); background: var(--text-strong); }
.preset-chip .count { font-size: var(--fs-sm); }
.preset-chip.selected .count { color: var(--bg-alt); }
.preset-manage { background: none; border: none; color: var(--text-muted); font-size: var(--fs); padding: 3px 6px; }
.preset-manage:hover { color: var(--text-strong); }

.suggested { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 20px; }
.suggested:empty { margin-bottom: 0; }
.sug { background: var(--text-10); border: none; color: var(--text-muted); font-size: var(--fs); }
.sug:hover { color: var(--text-strong); }
.sug.used { opacity: .35; cursor: default; }
.sug-label { color: var(--text-muted); font-size: var(--fs); }

.ranges { display: flex; gap: 8px; align-items: center; }
.rng {
  background: none; border: none; border-bottom: 1px solid transparent;
  color: var(--text-muted); font-size: var(--fs);
}
.rng:hover { color: var(--text-strong); }
.rng.on { color: var(--bg); background: var(--text-strong); border-bottom-color: var(--text-strong); }

.clear-btn { background: none; border: none; color: var(--text-muted); font-size: var(--fs); }
.clear-btn:hover { color: var(--red); }
.scan-btns { margin-left: auto; display: flex; gap: 8px; }
.scan-btn {
  background: var(--text-strong); border: none; color: var(--bg); font-size: var(--fs);
}
.scan-btn:hover:not(:disabled) { opacity: .8; }
.scan-btn:disabled { opacity: .5; cursor: default; }
.cancel-btn { background: var(--red-10); border: none; color: var(--red); font-size: var(--fs); }
.cancel-btn:hover { opacity: 0.8; }

.notice { padding: 12px 20px; font-size: var(--fs); border-bottom: 1px solid var(--border); }
.notice.err { color: var(--red); }
.notice.warn { color: var(--text-muted); }

.tweet-count { padding: 10px 20px; font-size: var(--fs); color: var(--text-muted); border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
.tweet-count:empty { display: none; }
#tweetCount:empty, #notices:empty, #tickerBar:empty, #scanActions:empty, #filterBar:empty, #results:empty { display: none; }
.tweet-count .dl-btn { margin-left: auto; }
.dots::after { content: ''; animation: dots 1.2s steps(4, end) infinite; }
@keyframes dots { 0% { content: ''; } 25% { content: '.'; } 50% { content: '..'; } 75% { content: '...'; } }

.ticker-bar {
  padding: 14px 20px; border-bottom: 1px solid var(--border);
  display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
}
.ticker-item { font-size: var(--fs); display: inline-flex; align-items: center; gap: 4px; white-space: nowrap; text-decoration: none; }
.ticker-item:hover { opacity: .7; }
.ticker-cnt { font-size: var(--fs-sm); opacity: .6; }

.filter-bar {
  padding: 12px 20px; border-bottom: 1px solid var(--border);
  display: flex; gap: 16px; align-items: center; flex-wrap: wrap;
}

.signal {
  padding: 20px; border-bottom: 1px solid var(--border);
}
.signal.hidden { display: none; }
.sig-top { font-size: calc(var(--fs) - 2px); color: var(--text-muted); margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
.sig-top a { color: var(--text-muted); text-decoration: none; }
.sig-top a:hover { color: var(--text-strong); }
.sig-tickers { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px; }
.ticker-tag { font-size: var(--fs); text-decoration: none; }
.ticker-tag:hover { opacity: .7; }
.ticker-tag .a { display: none; }
.sig-title { font-size: var(--fs-lg); color: var(--text-strong); font-weight: 500; line-height: 1.4; margin-bottom: 6px; }
.sig-summary { font-size: var(--fs); color: var(--text); line-height: 1.55; }
.sig-links { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; }
.ext-link { font-size: var(--fs); color: var(--text); text-decoration: none; background: var(--text-10); }
.ext-link:hover { background: var(--text-20); }
.sig-bottom { margin-top: 10px; font-size: var(--fs-sm); color: var(--text-muted); display: flex; align-items: center; gap: 6px; }
.sig-cat { color: inherit; }
.see-post { color: var(--text-muted); text-decoration: none; font-size: var(--fs); }
.see-post:hover { color: var(--text-strong); }
.see-post .arrow { display: none; }
@media (max-width: 700px) {
  .see-post .text { display: none; }
  .see-post .arrow { display: inline; }
}
.tweet-tooltip {
  position: fixed; z-index: 1000; max-width: 320px; padding: 12px 14px;
  background: var(--text-strong); color: var(--bg); font-size: var(--fs); line-height: 1.5;
  pointer-events: none; opacity: 0; border: 1px solid var(--text-strong);
}
.tweet-tooltip.vis { opacity: 1; }
.empty-state { padding: 48px 20px; font-size: var(--fs); color: var(--text-muted); text-align: center; }

.history:empty { display: none; }
.hist-item { padding: 10px 20px; border-bottom: 1px solid var(--border); }
.hist-item:last-child { border-bottom: none; }
.hist-item.open { padding-bottom: 0; }
.hist-header { display: flex; align-items: center; justify-content: space-between; }
.hist-toggle { background: none; border: none; color: var(--text-muted); font-size: var(--fs); padding: 0; cursor: pointer; }
.hist-toggle:hover { color: var(--text-strong); }
.hist-actions { display: flex; gap: 16px; }
.hist-actions button { background: none; border: none; color: var(--text-muted); font-size: var(--fs); cursor: pointer; }
.hist-actions button:hover { color: var(--text-strong); }
.hist-actions .delete:hover { color: var(--red); }
.hist-body { display: none; margin-left: 0; margin-top: 8px; }
.hist-meta { color: var(--text-muted); font-size: var(--fs); margin-bottom: 10px; }
.hist-cards .signal { margin-top: 0; padding-right: 0; border-left: 1px solid var(--border); }
.hist-cards .signal:last-child { border-bottom: none; }
.hist-item.open .hist-body { display: block; }

.scan-actions { padding: 12px 20px; border-bottom: 1px solid var(--border); display: flex; gap: 12px; align-items: center; }
.scan-actions .meta { font-size: var(--fs); color: var(--text-muted); flex: 1; }
.dl-btn {
  background: none; border: none;
  color: var(--text-muted); font-size: var(--fs); cursor: pointer;
}
.dl-btn:hover { color: var(--text-strong); }

.footer { padding: 10px 20px; font-size: var(--fs-sm); color: var(--text-muted); line-height: 1.6; }
.footer:empty { display: none; }
.footer a { color: var(--text-muted); }
.footer a:hover { color: var(--text); }

@media (max-width: 700px) {
  .topbar, .controls, .notice, .tweet-count, .ticker-bar, .scan-actions, .filter-bar, .signal, .footer, .hist-item {
    padding-left: 16px; padding-right: 16px;
  }
  .hide-mobile { display: none; }
  .modal input, .modal textarea, .modal select, .input-row input { font-size: 16px !important; } /* prevent iOS zoom on focus */
  .modal-bg { align-items: flex-end; padding: 0; }
  .modal { max-width: 100%; max-height: 85vh; border: none; border-top: 1px solid var(--border); padding: 20px; }
  .modal-actions { flex-direction: column-reverse; }
  .modal-actions button { width: 100%; padding: 12px; }
  .modal-actions button.danger { margin-right: 0; margin-top: 8px; }
}
</style>
</head>
<body>
<noscript>
  <div style="padding:40px;text-align:center;font-family:system-ui;color:#888">
    <h2 style="color:#ddd;margin-bottom:16px">JavaScript Required</h2>
    <p>Sentry requires JavaScript to function. Please enable JavaScript in your browser settings.</p>
  </div>
</noscript>

<!-- key modal -->
<div class="modal-bg" id="modal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal()">✕</button>
    <h3>Settings</h3>
    <p>Your API keys are stored locally in your browser and are only sent to their respective APIs — never to any third-party servers.<br>
    Get an X/Twitter API key at <a href="https://twitterapi.io" target="_blank">twitterapi.io</a>.<br>
    Get an Anthropic API key at <a href="https://console.anthropic.com/settings/keys" target="_blank">console.anthropic.com</a>.</p>
    <label>X/Twitter API key (twitterapi.io)</label>
    <input type="password" id="twKeyInput" placeholder="Your twitterapi.io key">
    <label>Anthropic API key</label>
    <input type="password" id="keyInput" placeholder="sk-ant-...">
    <label>Finance charts</label>
    <select id="financeProvider">
      <option value="yahoo">Yahoo Finance</option>
      <option value="google">Google Finance</option>
    </select>
    <label>Font</label>
    <select id="fontProvider">
      <option value="mono">Monospace</option>
      <option value="system">System</option>
    </select>
    <label>Font size</label>
    <select id="fontSizeProvider">
      <option value="xsmall">Extra Small</option>
      <option value="small">Small</option>
      <option value="medium">Medium</option>
      <option value="large">Large</option>
      <option value="xlarge">Extra Large</option>
    </select>
    <label>Text style</label>
    <select id="caseProvider">
      <option value="lower">lowercase</option>
      <option value="sentence">Sentence case</option>
    </select>
    <label>Analyst prompt <button type="button" class="reset-prompt" onclick="resetPrompt()">reset</button></label>
    <textarea id="promptInput" style="height:150px" placeholder="Custom instructions for the AI analyst..."></textarea>
    <label>Backup</label>
    <div style="display:flex;gap:8px">
      <button type="button" class="modal-sm-btn" id="exportBtn" onclick="exportData(this)">Export</button>
      <button type="button" class="modal-sm-btn" id="importBtn" onclick="importData(this)">Import</button>
    </div>
    <label>Cache</label>
    <div style="display:flex;gap:8px;align-items:center">
      <button type="button" class="modal-sm-btn" onclick="clearCache()">Clear cache</button>
      <span id="cacheSize" style="font-size:var(--fs-sm);color:var(--text-muted)"></span>
    </div>
    <div class="modal-actions">
      <button class="danger" id="clearKeyBtn" onclick="clearKeys()">Clear all</button>
      <button onclick="closeModal()">Cancel</button>
      <button onclick="saveKeys()">Save</button>
    </div>
  </div>
</div>

<!-- preset modal -->
<div class="modal-bg" id="presetModal">
  <div class="modal">
    <button class="modal-close" onclick="closePresetModal()">✕</button>
    <h3>Manage presets</h3>
    <p>Create lists of accounts for quick scanning.</p>
    <label>Preset name</label>
    <input type="text" id="presetNameInput" placeholder="E.g. Commodities">
    <label>Accounts (comma-separated)</label>
    <textarea id="presetAccountsInput" style="height:175px" placeholder="account1, account2, account3"></textarea>
    <div class="modal-actions">
      <button onclick="closePresetModal()">Cancel</button>
      <button onclick="savePreset()">Save preset</button>
    </div>
    <div class="preset-list" id="presetList"></div>
  </div>
</div>

<div class="topbar">
  <div class="logo">
    <span class="dot" id="dot">█</span>
    <span class="logo-text">Sentry</span>
  </div>
  <div class="topbar-right">
    <button class="top-btn" id="themeBtn" onclick="toggleTheme()">Theme</button>
    <button class="top-btn" id="keyBtn" onclick="openModal()">Settings</button>
  </div>
</div>

<div class="controls">
  <div class="input-row">
    <span class="at">@</span>
    <input type="text" id="acctInput" placeholder="Add account" autocomplete="off">
    <button class="add-btn" id="addBtn">Add</button>
  </div>
  <div class="presets-row" id="presetsRow"></div>
  <div class="suggested" id="suggested"></div>
  <div class="ranges" id="rangesRow"></div>
</div>

<div id="tweetCount"></div>
<div id="notices"></div>
<div id="tickerBar"></div>
<div id="scanActions"></div>
<div id="filterBar"></div>
<div id="results"></div>
<div id="historySection"></div>
<div class="footer" id="footer"></div>
<div class="tweet-tooltip" id="tweetTooltip"></div>

<script>
// --- Config ---
const DEFAULT_PRESETS = [
  { name: 'tradfi', accounts: ['ayz_yzyz', 'citrini7', 'jukan05', 'nicholastreece', 'zephyr_z9'] },
  { name: 'crypto', accounts: ['0xaporia', '0xGeeGee', '0xkyle__', '0xNairolf', '33b345', '__bleeker', 'AggrNews', 'ahboyash', 'awawat', 'BambouClub', 'based16z', 'blknoiz06', 'Bluntz_Capital', 'burstingbagel', 'c0xswain', 'Cbb0fe', 'Cheshire_Cap', 'choffstein', 'chortly', 'chrisgrx_', 'CL207', 'cobie', 'cryptoluffyy', 'Cryptopathic', 'danny_xbt', 'deaftrader1', 'defi_monk', 'DeFiyst', 'definalist', 'DegenPing', 'delucinator', 'DonAlt', 'Evan_ss6', 'FoftyPawlow', 'gametheorizing', 'goodalexander', 'hansolar21', 'HsakaTrades', 'Husslin_', 'ieaturfoods', 'inversebrah', 'jeff_w1098', 'kwaker_oats_', 'lBattleRhino', 'maruushae', 'mert', 'mlmabc', 'NachoTrades', 'NyuuRoe', 'PaperFlow8', 'pet3rpan_', 'PineAnalytics', 'pk79z', 'QwQiao', 'redphonecrypto', 'riddle245', 'rodeo_crypro', 'RunnerXBT', 'saliencexbt', 'sershokunin', 'TangTrades', 'Techno_Revenant', 'tetra_gamma', 'TheCryptoNexus', 'ThinkingUSD', 'trading_axe', 'TreeNewsFeed', 'tzedonn', 'velo_xyz', 'xmgnr', 'zoomerfied'] },
];
const MAX_RECENTS = 10; // how many recent accounts to show
const RANGES = [
  { label: 'Today', days: 1 },
  { label: 'This week', days: 7 },
  { label: 'This month', days: 30 },
];
const CATEGORIES = ['Trade', 'Tool', 'Insight', 'Resource'];
const CAT_C = { Trade: 'var(--green)', Tool: 'var(--blue)', Insight: 'var(--purple)', Resource: 'var(--amber)' };
// Migrate old category names
const CAT_MIGRATE = { 'Investment Idea': 'Trade', 'Tool / Product': 'Tool' };
function normCat(c) { return CAT_MIGRATE[c] || c; }
const ACT_C = { buy: 'var(--green)', sell: 'var(--red)', hold: 'var(--amber)', watch: 'var(--blue)', mixed: 'var(--purple)' };
const ACT_BG = { buy: 'var(--green-10)', sell: 'var(--red-10)', hold: 'var(--amber-10)', watch: 'var(--blue-10)', mixed: 'var(--purple-10)' };
const LS_TW = 'signal_twitter_key';
const LS_AN = 'signal_anthropic_key';
const LS_SCANS = 'signal_scan_history';
const LS_CURRENT = 'signal_current_scan';
const LS_PROMPT = 'signal_custom_prompt';
const DEFAULT_PROMPT = `You are a world-class financial analyst. Extract actionable trading signals from these tweets. Be thorough — every tweet with a tradeable opinion counts.

ACCURACY & INFERENCE RULES:
- Ground every signal in the specific tweet text associated with its tweet_url. Do NOT mix facts from other tweets.
- Inference is allowed but must be clearly framed (use "implies", "suggests", "seems to").
- Do NOT invent concrete claims (products, events, metrics, partnerships) not present in the tweet.
- If a tweet is vague, keep your summary appropriately vague.
- If a tweet quotes/replies to another, consider BOTH but clearly distinguish the source's opinion from the quoted content.

WRITING STYLE:
- Write for a smart generalist, not a finance insider.
- Avoid jargon unless essential — if you use it, briefly clarify (e.g. "TVL (total value locked)").
- Prefer plain language: "price looks cheap" over "valuation compressed", "buying opportunity" over "constructive setup".
- Titles should be scannable and self-explanatory in under 3 seconds.
- Summaries should answer: what's the opinion, and why?

Return a JSON array. Each signal:
- "title": A clear headline capturing the tweet's intent. Lead with ticker/company when relevant. Signal inference when present ("price drop may be overblown").
- "summary": 1-2 plain-language sentences summarizing the opinion and reasoning. Quote key phrases when useful; do not fabricate specifics.
- "category": "Trade" | "Tool" | "Insight" | "Resource"
- "source": twitter handle (no @)
- "tickers": [{symbol: "$TICKER", action: "buy"|"sell"|"hold"|"watch"}] — Extract ALL tickers mentioned. Yahoo Finance format: US stocks = symbol only ($AAPL), Taiwan = .TW ($2408.TW), Hong Kong = .HK, Japan = .T, Korea = .KS, crypto = symbol only ($BTC, $ETH).
- "tweet_url": exact tweet_url from data
- "links": external URLs mentioned (articles, substacks). Empty array if none.

Return ONLY valid JSON array. No markdown, no explanation.`;
const LS_ACCOUNTS = 'signal_accounts';
const LS_LOADED_PRESETS = 'signal_loaded_presets';
const LS_PRESETS = 'signal_presets';
const LS_THEME = 'signal_theme';
const LS_FINANCE = 'signal_finance_provider';
const LS_FONT = 'signal_font';
const LS_FONT_SIZE = 'signal_font_size';
const LS_CASE = 'signal_case';
const LS_RECENTS = 'signal_recent_accounts';
const LS_ANALYSIS_CACHE = 'signal_analysis_cache';
const ANALYSIS_MODEL = 'claude-sonnet-4-20250514';
const CORS_PROXY = 'https://sentry.tomaspalmeirim.workers.dev/?url=';

let customAccounts = [];      // manually added accounts
let loadedPresets = [];       // array of preset names currently loaded
let range = 1;
let lastScanResult = null;
let busy = false;
let logs = [];
let filters = { category: null };

// Get all accounts (presets + custom) for scanning
function getAllAccounts() {
  const all = [...customAccounts];
  const presets = getPresets();
  for (const name of loadedPresets) {
    const p = presets.find(p => p.name === name);
    if (p) all.push(...p.accounts);
  }
  return [...new Set(all)]; // dedupe
}

function hasAnyAccounts() {
  return customAccounts.length > 0 || loadedPresets.length > 0;
}

// --- DOM ---
const $ = id => document.getElementById(id);
const esc = s => { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; };

// --- Theme ---
function getTheme() { return localStorage.getItem(LS_THEME) || 'light'; }
function setTheme(t) {
  localStorage.setItem(LS_THEME, t);
  document.documentElement.setAttribute('data-theme', t);
}
function toggleTheme() { setTheme(getTheme() === 'dark' ? 'light' : 'dark'); }

// --- Presets ---
function getPresets() {
  const stored = localStorage.getItem(LS_PRESETS);
  if (!stored) {
    // Initialize with defaults on first load
    localStorage.setItem(LS_PRESETS, JSON.stringify(DEFAULT_PRESETS));
    return DEFAULT_PRESETS;
  }
  return JSON.parse(stored);
}
function savePresetsData(p) { localStorage.setItem(LS_PRESETS, JSON.stringify(p)); }
function loadPreset(name) {
  const preset = getPresets().find(p => p.name === name);
  if (!preset) return;
  
  // Toggle preset on/off
  if (loadedPresets.includes(name)) {
    loadedPresets = loadedPresets.filter(n => n !== name);
  } else {
    loadedPresets.push(name);
  }
  saveLoadedPresets();
  render();
}

function deletePreset(name) {
  savePresetsData(getPresets().filter(p => p.name !== name));
  renderPresets();
  renderPresetList();
}
function renderPresets() {
  const el = $('presetsRow');
  const presets = getPresets();
  let h = '';
  
  // Render preset chips (toggleable)
  presets.forEach(p => {
    const selected = loadedPresets.includes(p.name) ? ' selected' : '';
    h += `<button class="preset-chip${selected}" onclick="loadPreset('${esc(p.name)}')">${esc(p.name)} <span class="count">(${p.accounts.length})</span></button>`;
  });
  
  // Render custom accounts (toggleable - always selected since they're manually added)
  customAccounts.forEach(a => {
    h += `<button class="preset-chip selected" onclick="rmCustom('${esc(a)}')">${esc(a)}</button>`;
  });
  
  // Add preset button
  h += `<button class="preset-manage" onclick="openPresetModal()">+</button>`;
  
  // Clear button (only if there are accounts)
  if (loadedPresets.length > 0 || customAccounts.length > 0) {
    h += `<button class="clear-btn" onclick="clearAllAccounts()">×</button>`;
  }
  
  el.innerHTML = h;
}
let editingPresetName = null; // track if editing an existing preset

function openPresetModal() {
  editingPresetName = null;
  $('presetNameInput').value = '';
  $('presetAccountsInput').value = getAllAccounts().join(', ');
  renderPresetList();
  $('presetModal').classList.add('open');
  $('presetNameInput').focus();
}
function closePresetModal() {
  editingPresetName = null;
  $('presetModal').classList.remove('open');
}
function editPreset(name) {
  const preset = getPresets().find(p => p.name === name);
  if (!preset) return;
  editingPresetName = name;
  $('presetNameInput').value = preset.name;
  $('presetAccountsInput').value = preset.accounts.join(', ');
  $('presetNameInput').focus();
  renderPresetList();
}
function savePreset() {
  const name = $('presetNameInput').value.trim();
  const accountsStr = $('presetAccountsInput').value;
  const accts = accountsStr.split(',').map(a => a.trim().replace(/^@/, '').toLowerCase()).filter(a => a);
  if (!name || !accts.length) return;
  
  let presets = getPresets();
  if (editingPresetName) {
    // Update existing preset
    presets = presets.filter(p => p.name !== editingPresetName);
  }
  presets = presets.filter(p => p.name !== name);
  presets.push({ name, accounts: accts });
  savePresetsData(presets);
  
  // Update loaded presets if name changed
  if (editingPresetName && editingPresetName !== name && loadedPresets.includes(editingPresetName)) {
    loadedPresets = loadedPresets.map(n => n === editingPresetName ? name : n);
    saveLoadedPresets();
  }
  
  editingPresetName = null;
  renderPresets();
  renderPresetList();
  render();
  $('presetNameInput').value = '';
  $('presetAccountsInput').value = '';
}
function renderPresetList() {
  const el = $('presetList');
  const presets = getPresets();
  if (!presets.length) { el.innerHTML = '<p style="color:var(--text-muted);font-size:var(--fs);margin-top:8px">No presets yet</p>'; return; }
  el.innerHTML = presets.map(p => {
    const isEditing = editingPresetName === p.name;
    return `
    <div class="preset-list-item${isEditing ? ' editing' : ''}">
      <span>${esc(p.name)}<small>${p.accounts.length} accounts</small></span>
      <div class="preset-list-actions">
        <button onclick="editPreset('${esc(p.name)}')">${isEditing ? 'Editing' : 'Edit'}</button>
        <button class="danger" onclick="deletePreset('${esc(p.name)}')">Delete</button>
      </div>
    </div>
  `}).join('');
}
// Only close modal if mousedown AND mouseup both happen on backdrop
let presetModalMouseDownTarget = null;
$('presetModal').addEventListener('mousedown', e => { presetModalMouseDownTarget = e.target; });
$('presetModal').addEventListener('click', e => {
  if (e.target === $('presetModal') && presetModalMouseDownTarget === $('presetModal')) closePresetModal();
  presetModalMouseDownTarget = null;
});
$('presetNameInput').addEventListener('keydown', e => { if (e.key === 'Enter') $('presetAccountsInput').focus(); });
$('presetAccountsInput').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); savePreset(); } });

// --- Account Persistence ---
function saveAccounts() { localStorage.setItem(LS_ACCOUNTS, JSON.stringify(customAccounts)); }
function loadAccountsData() {
  const saved = localStorage.getItem(LS_ACCOUNTS);
  if (saved) customAccounts = JSON.parse(saved);
}
function saveLoadedPresets() { localStorage.setItem(LS_LOADED_PRESETS, JSON.stringify(loadedPresets)); }
function loadLoadedPresets() {
  const saved = localStorage.getItem(LS_LOADED_PRESETS);
  if (saved) loadedPresets = JSON.parse(saved);
}

// --- Recent Accounts ---
function getRecents() {
  return JSON.parse(localStorage.getItem(LS_RECENTS) || '[]');
}
function addToRecents(accounts) {
  let recents = getRecents();
  // Add new accounts to front, remove duplicates
  accounts.forEach(a => {
    recents = recents.filter(r => r !== a);
    recents.unshift(a);
  });
  // Keep only MAX_RECENTS
  recents = recents.slice(0, MAX_RECENTS);
  localStorage.setItem(LS_RECENTS, JSON.stringify(recents));
}
function clearRecents() {
  localStorage.removeItem(LS_RECENTS);
  renderSuggested();
}

// ============================================================================
// API KEYS & SETTINGS - With validation
// ============================================================================

function getTwKey() { return localStorage.getItem(LS_TW) || ''; }
function getAnKey() { return localStorage.getItem(LS_AN) || ''; }

// Check if both keys exist and have reasonable format
function bothKeys() {
  const tw = getTwKey();
  const an = getAnKey();
  // Basic validation: keys should be non-empty and have reasonable length
  return tw.length >= 20 && an.length >= 20;
}

// Validate API key format (basic sanity check)
function validateApiKey(key, type) {
  if (!key || typeof key !== 'string') return false;
  key = key.trim();
  if (key.length < 20) return false;
  // Anthropic keys start with sk-ant-
  if (type === 'anthropic' && !key.startsWith('sk-ant-')) return false;
  return true;
}

function getFinanceProvider() { return localStorage.getItem(LS_FINANCE) || 'yahoo'; }
function getFont() { return localStorage.getItem(LS_FONT) || 'mono'; }
function setFont(f) {
  localStorage.setItem(LS_FONT, f);
  document.documentElement.setAttribute('data-font', f);
}
function getFontSize() { return localStorage.getItem(LS_FONT_SIZE) || 'medium'; }
function setFontSize(s) {
  localStorage.setItem(LS_FONT_SIZE, s);
  document.documentElement.setAttribute('data-font-size', s);
}
function getCase() { return localStorage.getItem(LS_CASE) || 'lower'; }
function setCase(c) {
  localStorage.setItem(LS_CASE, c);
  document.documentElement.setAttribute('data-case', c);
}
function getPrompt() { return localStorage.getItem(LS_PROMPT) || DEFAULT_PROMPT; }
function setPrompt(p) { localStorage.setItem(LS_PROMPT, p); }
function resetPrompt() { $('promptInput').value = DEFAULT_PROMPT; }

// --- Analysis Cache ---
const MAX_CACHE_ENTRIES = 2000;
function hashString(str) {
  let h = 5381;
  for (let i = 0; i < str.length; i++) {
    h = ((h << 5) + h) + str.charCodeAt(i);
    h |= 0;
  }
  return (h >>> 0).toString(16);
}
function getPromptHash() {
  return hashString(`${ANALYSIS_MODEL}\n${getPrompt()}`);
}
function loadAnalysisCache() {
  try {
    const raw = localStorage.getItem(LS_ANALYSIS_CACHE);
    const parsed = raw ? JSON.parse(raw) : null;
    if (parsed && parsed.entries) return parsed;
  } catch {}
  return { v: 1, entries: {} };
}
function saveAnalysisCache(cache) {
  try {
    localStorage.setItem(LS_ANALYSIS_CACHE, JSON.stringify(cache));
  } catch (e) {
    console.warn('Failed to save analysis cache:', e.message);
  }
}
function cacheKey(promptHash, tweetUrl) {
  return `${promptHash}:${tweetUrl}`;
}
function getCachedSignals(cache, promptHash, tweetUrl) {
  if (!tweetUrl) return null;
  const entry = cache.entries[cacheKey(promptHash, tweetUrl)];
  return entry ? entry.signals || [] : null;
}
function setCachedSignals(cache, promptHash, tweetUrl, signals) {
  if (!tweetUrl) return;
  cache.entries[cacheKey(promptHash, tweetUrl)] = { signals: signals || [], ts: Date.now() };
}
function pruneCache(cache) {
  const keys = Object.keys(cache.entries);
  if (keys.length <= MAX_CACHE_ENTRIES) return;
  keys.sort((a, b) => (cache.entries[a]?.ts || 0) - (cache.entries[b]?.ts || 0));
  const removeCount = keys.length - MAX_CACHE_ENTRIES;
  for (let i = 0; i < removeCount; i++) {
    delete cache.entries[keys[i]];
  }
}

// Cache cleanup (called on init)
function cleanupCache() {
  // Clear old tweet cache entries (older than 2 hours)
  const now = Date.now();
  const twoHoursAgo = Math.floor(now / 3600000) - 2;
  for (const [key] of tweetCache) {
    const keyHour = parseInt(key.split(':')[2]);
    if (keyHour < twoHoursAgo) {
      tweetCache.delete(key);
    }
  }
}

function openModal() {
  $('twKeyInput').value = getTwKey();
  $('keyInput').value = getAnKey();
  $('financeProvider').value = getFinanceProvider();
  $('fontProvider').value = getFont();
  $('fontSizeProvider').value = getFontSize();
  $('caseProvider').value = getCase();
  $('promptInput').value = getPrompt();
  updateCacheSizeDisplay();
  $('modal').classList.add('open');
  $('clearKeyBtn').style.display = (getTwKey() || getAnKey()) ? '' : 'none';
  setTimeout(() => $('twKeyInput').focus(), 50);
}

function updateCacheSizeDisplay() {
  const cache = loadAnalysisCache();
  const count = Object.keys(cache.entries || {}).length;
  $('cacheSize').textContent = count ? `${count} tweets cached` : 'empty';
}

function clearCache() {
  if (!confirm('Clear all cached analysis results?')) return;
  localStorage.removeItem(LS_ANALYSIS_CACHE);
  updateCacheSizeDisplay();
}
function closeModal() { $('modal').classList.remove('open'); }
function saveKeys() {
  const tw = $('twKeyInput').value.trim();
  const an = $('keyInput').value.trim();
  const fp = $('financeProvider').value;
  const font = $('fontProvider').value;
  const fontSize = $('fontSizeProvider').value;
  const textCase = $('caseProvider').value;
  const prompt = $('promptInput').value.trim();
  if (tw) localStorage.setItem(LS_TW, tw); else localStorage.removeItem(LS_TW);
  if (an) localStorage.setItem(LS_AN, an); else localStorage.removeItem(LS_AN);
  localStorage.setItem(LS_FINANCE, fp);
  setFont(font);
  setFontSize(fontSize);
  setCase(textCase);
  setPrompt(prompt || DEFAULT_PROMPT);
  updateKeyBtn();
  closeModal();
}
function clearKeys() {
  localStorage.removeItem(LS_TW);
  localStorage.removeItem(LS_AN);
  $('twKeyInput').value = '';
  $('keyInput').value = '';
  updateKeyBtn();
  closeModal();
}
function encodeBackup(str) {
  return btoa(unescape(encodeURIComponent(str)));
}
function decodeBackup(str) {
  return decodeURIComponent(escape(atob(str)));
}
async function exportData(btn) {
  const data = {
    v: 1,
    settings: {
      theme: getTheme(),
      font: getFont(),
      fontSize: getFontSize(),
      textCase: getCase(),
      financeProvider: getFinanceProvider(),
      prompt: getPrompt(),
    },
    keys: { twitter: getTwKey(), anthropic: getAnKey() },
    presets: getPresets(),
    accounts: customAccounts,
    loadedPresets: loadedPresets,
    recents: getRecents(),
  };
  const encoded = encodeBackup(JSON.stringify(data));
  await navigator.clipboard.writeText(encoded);
  if (btn) {
    btn.textContent = 'Copied';
    setTimeout(() => { btn.textContent = 'Export'; }, 1500);
  }
}
async function importData(btn) {
  try {
    const encoded = await navigator.clipboard.readText();
    const json = decodeBackup(encoded.trim());
    const data = JSON.parse(json);
    if (!data.v && !data.version) throw new Error('Invalid backup format');
    
    if (data.settings) {
      if (data.settings.theme) setTheme(data.settings.theme);
      if (data.settings.font) setFont(data.settings.font);
      if (data.settings.fontSize) setFontSize(data.settings.fontSize);
      if (data.settings.textCase) setCase(data.settings.textCase);
      if (data.settings.financeProvider) localStorage.setItem(LS_FINANCE, data.settings.financeProvider);
      if (data.settings.prompt) setPrompt(data.settings.prompt);
    }
    if (data.keys) {
      if (data.keys.twitter) localStorage.setItem(LS_TW, data.keys.twitter);
      if (data.keys.anthropic) localStorage.setItem(LS_AN, data.keys.anthropic);
    }
    if (data.presets) savePresetsData(data.presets);
    if (data.accounts) { customAccounts = data.accounts; saveAccounts(); }
    if (data.loadedPresets) { loadedPresets = data.loadedPresets; saveLoadedPresets(); }
    if (data.recents) localStorage.setItem(LS_RECENTS, JSON.stringify(data.recents));
    
    // Refresh modal inputs
    $('twKeyInput').value = getTwKey();
    $('keyInput').value = getAnKey();
    $('financeProvider').value = getFinanceProvider();
    $('fontProvider').value = getFont();
    $('fontSizeProvider').value = getFontSize();
    $('caseProvider').value = getCase();
    $('promptInput').value = getPrompt();
    updateKeyBtn();
    render();
    
    if (btn) {
      btn.textContent = 'Success';
      btn.style.color = 'var(--green)';
      setTimeout(() => { btn.textContent = 'Import'; btn.style.color = ''; }, 1500);
    }
  } catch (err) {
    console.warn('Import failed:', err);
    if (btn) {
      const msg = err.message.includes('clipboard') ? 'Clipboard error' : 'Invalid backup';
      btn.textContent = msg;
      btn.style.color = 'var(--red)';
      setTimeout(() => { btn.textContent = 'Import'; btn.style.color = ''; }, 2000);
    }
  }
}
function updateKeyBtn() {
  const ok = bothKeys();
  $('keyBtn').classList.toggle('warn', !ok);
  $('keyBtn').textContent = 'Settings';
}
// Only close modal if mousedown AND mouseup both happen on backdrop
let modalMouseDownTarget = null;
$('modal').addEventListener('mousedown', e => { modalMouseDownTarget = e.target; });
$('modal').addEventListener('click', e => {
  if (e.target === $('modal') && modalMouseDownTarget === $('modal')) closeModal();
  modalMouseDownTarget = null;
});
$('twKeyInput').addEventListener('keydown', e => { if (e.key === 'Enter') $('keyInput').focus(); });
$('keyInput').addEventListener('keydown', e => { if (e.key === 'Enter') saveKeys(); });
updateKeyBtn();

// --- Accounts ---
function add(h) {
  const c = h.trim().replace(/^@/, '').toLowerCase();
  if (c && !customAccounts.includes(c)) customAccounts.push(c);
  $('acctInput').value = '';
  $('addBtn').classList.remove('vis');
  saveAccounts();
  render();
  $('acctInput').focus();
}
function rmCustom(h) {
  customAccounts = customAccounts.filter(a => a !== h);
  saveAccounts();
  render();
}

$('acctInput').addEventListener('input', function() {
  this.value = this.value.replace(/^@/, '');
  $('addBtn').classList.toggle('vis', this.value.trim().length > 0);
});
$('acctInput').addEventListener('keydown', e => {
  if (e.key === 'Enter' && $('acctInput').value.trim()) { e.preventDefault(); add($('acctInput').value); }
});
$('addBtn').addEventListener('click', () => { if ($('acctInput').value.trim()) add($('acctInput').value); });

// --- Render helpers ---
function render() { renderPresets(); renderSuggested(); renderRanges(); }

function renderSuggested() {
  const el = $('suggested');
  const recents = getRecents();
  if (!recents.length) { el.innerHTML = ''; return; }
  
  const allAccounts = getAllAccounts();
  el.innerHTML = '';
  
  const label = document.createElement('span');
  label.className = 'sug-label';
  label.textContent = 'recents ·';
  el.appendChild(label);
  
  recents.forEach(s => {
    const b = document.createElement('button');
    b.className = 'sug' + (allAccounts.includes(s) ? ' used' : '');
    b.textContent = s;
    if (!allAccounts.includes(s)) b.addEventListener('click', () => add(s));
    el.appendChild(b);
  });
  
  const clearBtn = document.createElement('button');
  clearBtn.className = 'clear-btn';
  clearBtn.textContent = '×';
  clearBtn.addEventListener('click', clearRecents);
  el.appendChild(clearBtn);
}

function renderRanges() {
  const row = $('rangesRow');
  let h = '';
  
  // Date range selectors
  RANGES.forEach((r, i) => {
    const on = range === i ? ' on' : '';
    h += `<button class="rng${on}" onclick="range=${i};renderRanges();">${r.label}</button>`;
  });
  
  // Right side: scan buttons
  h += `<div class="scan-btns">`;
  if (busy) {
    h += `<button class="cancel-btn" onclick="abortCurrentScan(); setLoading(false); setStatus('Scan cancelled');">Cancel</button>`;
  }
  h += `<button class="scan-btn"${busy ? ' disabled' : ''} onclick="run()">${busy ? 'Scanning...' : 'Scan'}</button>`;
  h += `</div>`;
  
  row.innerHTML = h;
}


function clearAllAccounts() {
  customAccounts = [];
  loadedPresets = [];
  saveAccounts();
  saveLoadedPresets();
  render();
}

function setLoading(v) {
  busy = v;
  $('dot').classList.toggle('loading', v);
  renderRanges();
}
function setStatus(t, animate = false, showDownload = false) {
  const el = $('tweetCount');
  if (!t) { el.innerHTML = ''; return; }
  const dl = showDownload ? `<button class="dl-btn" onclick="downloadLastScan()">↓ <span class="hide-mobile">Download</span></button>` : '';
  el.innerHTML = `<div class="tweet-count">${t}${animate ? '<span class="dots"></span>' : ''}${dl}</div>`;
}

// ============================================================================
// TWITTER API - Robust fetching with caching and intelligent retry
// ============================================================================

// In-memory cache for tweets (prevents re-fetching on analysis failures)
const tweetCache = new Map();

function getCacheKey(account, days) {
  // Cache key includes hour to allow reasonable freshness while preventing spam
  const hour = Math.floor(Date.now() / 3600000);
  return `${account}:${days}:${hour}`;
}

async function fetchTweetsWithRetry(account, days, maxRetries = 3, signal = null) {
  const cacheKey = getCacheKey(account, days);
  
  // Return cached data if available (from this session)
  if (tweetCache.has(cacheKey)) {
    console.log(`[${account}] Using cached tweets`);
    return tweetCache.get(cacheKey);
  }
  
  const key = getTwKey();
  if (!key) throw new Error('No Twitter API key configured. Add it in Settings.');

  const cutoff = new Date(Date.now() - days * 86400000);
  console.log(`[${account}] Fetching tweets since ${cutoff.toISOString()} (${days} days)`);
  
  const allTweets = [];
  let cursor = null;
  let pages = 0;
  const MAX_PAGES = 5;
  let consecutiveErrors = 0;

  while (pages < MAX_PAGES) {
    // Check for abort at start of each page
    if (signal?.aborted) throw new DOMException('Scan cancelled', 'AbortError');
    
    const params = new URLSearchParams({ userName: account });
    if (cursor) params.set('cursor', cursor);

    const targetUrl = `https://api.twitterapi.io/twitter/user/last_tweets?${params}`;
    const fetchUrl = CORS_PROXY + encodeURIComponent(targetUrl);

    let res, data;
    let pageRetries = 0;
    
    while (pageRetries <= maxRetries) {
      if (signal?.aborted) throw new DOMException('Scan cancelled', 'AbortError');
      try {
        res = await fetch(fetchUrl, {
          method: 'GET',
          headers: {
            'X-API-Key': key,
            'Accept': 'application/json',
          },
          signal,
        });

        // Auth errors - fail immediately, no retry
        if (res.status === 401 || res.status === 403) {
          const body = await res.text().catch(() => '');
          throw new Error(`Twitter API auth error: ${body.slice(0, 100) || 'invalid key'}`);
        }
        
        // Rate limit - wait with backoff
        if (res.status === 429) {
          const waitMs = backoffDelay(pageRetries, 5000, 30000);
          console.log(`[${account}] Rate limited, waiting ${Math.ceil(waitMs/1000)}s...`);
          await new Promise(r => setTimeout(r, waitMs));
          pageRetries++;
          continue;
        }
        
        // Other HTTP errors
        if (!res.ok) {
          if (pageRetries < maxRetries) {
            await new Promise(r => setTimeout(r, backoffDelay(pageRetries, 1000, 10000)));
            pageRetries++;
            continue;
          }
          const body = await res.text().catch(() => '');
          throw new Error(`Twitter API error ${res.status}: ${body.slice(0, 100) || res.statusText}`);
        }

        // Parse response
        const text = await res.text();
        try {
          data = JSON.parse(text);
        } catch (e) {
          console.warn(`[${account}] Invalid JSON response, retrying...`);
          if (pageRetries < maxRetries) {
            pageRetries++;
            continue;
          }
          throw new Error('Invalid JSON from Twitter API');
        }
        
        break; // Success, exit retry loop
        
      } catch (e) {
        // AbortError - don't retry, just throw
        if (e.name === 'AbortError') throw e;
        if (e.message.includes('auth error') || e.message.includes('No Twitter API')) {
          throw e; // Don't retry auth errors
        }
        if (pageRetries >= maxRetries) {
          throw e;
        }
        console.warn(`[${account}] Fetch error, retrying:`, e.message);
        await new Promise(r => setTimeout(r, backoffDelay(pageRetries, 1000, 10000)));
        pageRetries++;
      }
    }

    // Process response data
    const apiData = data.data || data;
    
    if (data.status === 'error' || (data.status !== 'success' && data.message)) {
      consecutiveErrors++;
      if (consecutiveErrors >= 2) {
        console.warn(`[${account}] Multiple consecutive errors, stopping`);
        break;
      }
      continue;
    }
    
    consecutiveErrors = 0; // Reset on success

    const tweets = apiData.tweets || [];
    if (!tweets.length) {
      console.log(`[${account}] No more tweets`);
      break;
    }

    let hitCutoff = false;
    for (const tw of tweets) {
      const created = new Date(tw.createdAt);
      if (created < cutoff) { hitCutoff = true; break; }
      allTweets.push(tw);
    }

    if (hitCutoff) break;
    if (!apiData.has_next_page || !apiData.next_cursor) break;
    cursor = apiData.next_cursor;
    pages++;
    
    // Small delay between pagination
    await new Promise(r => setTimeout(r, 100));
  }

  // Cache the results
  if (allTweets.length > 0) {
    tweetCache.set(cacheKey, allTweets);
    console.log(`[${account}] Cached ${allTweets.length} tweets`);
  }

  return allTweets;
}

// Legacy alias for compatibility
async function fetchTweets(account, days) {
  return fetchTweetsWithRetry(account, days);
}

// ============================================================================
// TEXT SANITIZATION & JSON PARSING - Bulletproof handling
// ============================================================================

// Remove invalid Unicode (orphan surrogates) that break JSON
// Safari-compatible version (no lookbehind assertions)
function sanitizeText(str) {
  if (!str) return '';
  if (typeof str !== 'string') return String(str);
  
  // Remove lone surrogates and problematic characters
  // Process character by character for Safari compatibility
  let result = '';
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    // Skip control characters
    if ((code >= 0x00 && code <= 0x08) || code === 0x0B || code === 0x0C || 
        (code >= 0x0E && code <= 0x1F) || code === 0x7F || code === 0xFFFD) continue;
    // Handle surrogates
    if (code >= 0xD800 && code <= 0xDBFF) {
      // High surrogate - check if followed by low surrogate
      const next = str.charCodeAt(i + 1);
      if (next >= 0xDC00 && next <= 0xDFFF) {
        result += str[i] + str[i + 1];
        i++; // Skip the low surrogate
      }
      // else: orphan high surrogate, skip it
    } else if (code >= 0xDC00 && code <= 0xDFFF) {
      // Orphan low surrogate (not preceded by high), skip it
      continue;
    } else {
      result += str[i];
    }
  }
  return result;
}

// Safe JSON parsing with multiple fallbacks
function safeParseSignals(text) {
  if (!text) return [];
  
  // Clean the text
  let clean = text
    .replace(/```json\s*/gi, '')
    .replace(/```\s*/g, '')
    .trim();
  
  // Try to extract JSON array
  const arrayMatch = clean.match(/\[[\s\S]*\]/);
  if (!arrayMatch) {
    console.warn('No JSON array found in response');
    return [];
  }
  
  let jsonStr = arrayMatch[0];
  
  // Attempt 1: Direct parse
  try {
    const result = JSON.parse(jsonStr);
    if (Array.isArray(result)) return result;
  } catch (e) {
    console.warn('Direct JSON parse failed, attempting fixes...');
  }
  
  // Attempt 2: Fix common issues
  try {
    // Fix trailing commas
    jsonStr = jsonStr.replace(/,\s*]/g, ']').replace(/,\s*}/g, '}');
    // Fix unescaped newlines in strings
    jsonStr = jsonStr.replace(/([^\\])\\n(?=")/g, '$1\\\\n');
    const result = JSON.parse(jsonStr);
    if (Array.isArray(result)) return result;
  } catch (e) {
    console.warn('Fixed JSON parse failed:', e.message);
  }
  
  // Attempt 3: Sanitize and try again
  try {
    jsonStr = sanitizeText(jsonStr);
    const result = JSON.parse(jsonStr);
    if (Array.isArray(result)) return result;
  } catch (e) {
    console.error('All JSON parse attempts failed:', e.message);
  }
  
  return [];
}

function getTweetUrl(tw) {
  return tw.url || `https://x.com/i/status/${tw.id}`;
}

function formatTweetForAnalysis(tw) {
  const date = new Date(tw.createdAt).toISOString().slice(0, 16).replace('T', ' ');
  const engagement = `${tw.likeCount || 0}♥ ${tw.retweetCount || 0}↻ ${tw.viewCount || 0}👁`;
  const url = getTweetUrl(tw);
  let text = sanitizeText(tw.text || '');

  // collect external URLs (exclude twitter/x.com links)
  const externalLinks = [];
  if (tw.entities?.urls) {
    for (const u of tw.entities.urls) {
      if (u.url && u.expanded_url) {
        const expandedUrl = sanitizeText(u.expanded_url);
        text = text.replace(u.url, expandedUrl);
        // filter out twitter/x.com internal links
        if (!expandedUrl.match(/^https?:\/\/(twitter\.com|x\.com|t\.co)\//)) {
          externalLinks.push(expandedUrl);
        }
      }
    }
  }

  const parts = [`[${date}] ${text}`, `engagement: ${engagement}`, `tweet_url: ${url}`];
  if (externalLinks.length) parts.push(`external_links: ${externalLinks.join(', ')}`);
  if (tw.isReply) parts.push(`(reply to @${tw.inReplyToUsername || 'unknown'})`);
  if (tw.quoted_tweet) {
    const quotedText = sanitizeText(tw.quoted_tweet.text || '');
    const quotedAuthor = tw.quoted_tweet.author?.userName || 'unknown';
    parts.push(`--- QUOTED TWEET from @${quotedAuthor} ---\n${quotedText}\n--- END QUOTED TWEET ---`);
  }

  return parts.join('\n');
}

// ============================================================================
// ROBUST API LAYER - Bulletproof retry logic with exponential backoff + jitter
// ============================================================================

const API_CONFIG = {
  anthropic: {
    baseUrl: 'https://api.anthropic.com/v1/messages',
    maxRetries: 5,
    baseDelay: 2000,
    maxDelay: 120000, // 2 minutes max wait
    jitterFactor: 0.3,
  }
};

// Sleep with exponential backoff + jitter (prevents thundering herd)
function backoffDelay(attempt, baseDelay = 2000, maxDelay = 60000, jitter = 0.3) {
  const exponentialDelay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
  const jitterAmount = exponentialDelay * jitter * Math.random();
  return exponentialDelay + jitterAmount;
}

// Update status safely
function updateStatus(msg, animate = false) {
  const el = document.getElementById('tweetCount');
  if (!el) return;
  if (!msg) { el.innerHTML = ''; return; }
  el.innerHTML = `<div class="tweet-count">${msg}${animate ? '<span class="dots"></span>' : ''}</div>`;
}

// Categorize errors for appropriate handling
function categorizeError(error, status) {
  if (status === 429 || status === 529) return 'rate_limit';
  if (error?.type === 'overloaded_error') return 'overloaded';
  if (error?.type === 'rate_limit_error') return 'rate_limit';
  if (error?.message?.includes('quota')) return 'quota';
  if (error?.message?.includes('rate')) return 'rate_limit';
  if (error?.message?.includes('limit')) return 'rate_limit';
  if (error?.message?.includes('prompt is too long')) return 'input_too_large';
  if (error?.type === 'not_found_error') return 'model_not_found';
  if (error?.type === 'authentication_error') return 'auth_error';
  if (error?.type === 'invalid_request_error') return 'invalid_request';
  return 'unknown';
}

// Robust Anthropic API call with intelligent retry
async function anthropicCall(body, maxRetries = API_CONFIG.anthropic.maxRetries, signal = null) {
  const key = getAnKey();
  if (!key) throw new Error('No Anthropic API key configured. Add it in Settings.');
  
  let lastError = null;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    if (signal?.aborted) throw new DOMException('Scan cancelled', 'AbortError');
    try {
      const res = await fetch(API_CONFIG.anthropic.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': key,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true',
        },
        body: JSON.stringify(body),
        signal,
      });
      
      const data = await res.json();
      
      // Success
      if (!data.error) {
        if (attempt > 0) console.log(`✓ Anthropic succeeded on attempt ${attempt + 1}`);
        return data;
      }
      
      // Error handling
      const errorType = categorizeError(data.error, res.status);
      console.warn(`Anthropic error (attempt ${attempt + 1}/${maxRetries + 1}):`, errorType, data.error?.message);
      
      // Non-retryable errors - fail immediately
      if (['input_too_large', 'model_not_found', 'auth_error', 'invalid_request'].includes(errorType)) {
        const messages = {
          input_too_large: 'Input too large. Try fewer accounts or a shorter time range.',
          model_not_found: 'Model not available. Your API key may not have access to this model.',
          auth_error: 'Invalid API key. Please check your Anthropic API key in Settings.',
          invalid_request: data.error?.message || 'Invalid request to Anthropic API.',
        };
        throw new Error(messages[errorType] || data.error?.message);
      }
      
      // Retryable errors - wait with backoff
      if (['rate_limit', 'overloaded', 'quota'].includes(errorType)) {
        if (attempt >= maxRetries) {
          throw new Error(`API rate limited after ${maxRetries + 1} attempts. Please wait a few minutes and try again.`);
        }
        
        // Longer waits for quota/rate limit errors
        const baseWait = errorType === 'quota' ? 45000 : 15000;
        const waitMs = backoffDelay(attempt, baseWait, API_CONFIG.anthropic.maxDelay);
        const waitSecs = Math.ceil(waitMs / 1000);
        
        updateStatus(`Rate limited · Retry ${attempt + 2}/${maxRetries + 1} in ${waitSecs}s`, true);
        console.log(`Waiting ${waitSecs}s before retry...`);
        await new Promise(r => setTimeout(r, waitMs));
        continue;
      }
      
      // Unknown error - store and retry with shorter backoff
      lastError = data.error;
      if (attempt < maxRetries) {
        const waitMs = backoffDelay(attempt, 2000, 30000);
        await new Promise(r => setTimeout(r, waitMs));
      }
      
    } catch (e) {
      // AbortError - don't retry, just throw
      if (e.name === 'AbortError') throw e;
      
      // Network errors, JSON parse errors, etc.
      if (e.message.includes('No Anthropic') || e.message.includes('Invalid API') || 
          e.message.includes('Input too large') || e.message.includes('Model not available')) {
        throw e; // Don't retry these
      }
      
      lastError = e;
      console.warn(`Anthropic fetch error (attempt ${attempt + 1}):`, e.message);
      
      if (attempt < maxRetries) {
        const waitMs = backoffDelay(attempt, 3000, 30000);
        await new Promise(r => setTimeout(r, waitMs));
      }
    }
  }
  
  throw new Error(lastError?.message || 'Failed to connect to Anthropic API after multiple attempts.');
}

function extractText(content) {
  if (!content) return '';
  if (typeof content === 'string') return content;
  if (!Array.isArray(content)) return '';
  return content.filter(b => b.type === 'text' && b.text).map(b => b.text).join('\n');
}

// ============================================================================
// SCAN ENGINE - Orchestrates the complete scan workflow
// ============================================================================

// Scan state for abort support
let currentScanAbort = null;

function abortCurrentScan() {
  if (currentScanAbort) {
    currentScanAbort.abort();
    currentScanAbort = null;
  }
}

// Fetch all accounts' tweets with progress tracking
async function fetchAllTweets(accounts, days, onProgress, signal) {
  const BATCH_SIZE = 2; // Parallel fetch count
  const accountTweets = [];
  
  for (let i = 0; i < accounts.length; i += BATCH_SIZE) {
    // Check for abort before starting batch
    if (signal?.aborted) throw new DOMException('Scan cancelled', 'AbortError');
    
    const batch = accounts.slice(i, i + BATCH_SIZE);
    const progress = Math.round((i / accounts.length) * 100);
    onProgress?.(`Fetching ${i + 1}-${Math.min(i + batch.length, accounts.length)} of ${accounts.length}`);
    
    const results = await Promise.all(batch.map(async (account) => {
      if (signal?.aborted) return { account, tweets: [], error: 'Cancelled' };
      try {
        const tweets = await fetchTweetsWithRetry(account, days, 3, signal);
        return { account, tweets, error: null };
      } catch (e) {
        if (e.name === 'AbortError') throw e;
        console.warn(`[${account}] Fetch failed:`, e.message);
        return { account, tweets: [], error: e.message };
      }
    }));
    
    accountTweets.push(...results);
    
    // Small delay between batches (prevent rate limiting)
    if (i + BATCH_SIZE < accounts.length) {
      await new Promise(r => setTimeout(r, 150));
    }
  }
  
  return accountTweets;
}

// Analyze tweets with intelligent batching
const ANALYSIS_CONCURRENCY = 2;
const MAX_BATCH_CHARS = 640000; // ~160k tokens
const BATCH_SEPARATOR = '\n\n======\n\n';

function buildBatches(accountData, promptChars) {
  const items = accountData.map(a => {
    const header = `=== @${a.account} (${a.tweets.length} tweets) ===`;
    const body = a.tweets.map(formatTweetForAnalysis).join('\n---\n');
    const accountText = `${header}\n${body}`;
    const tweetUrls = a.tweets.map(getTweetUrl).filter(Boolean);
    return { account: a.account, text: accountText, size: accountText.length, tweetUrls };
  });

  // First-fit decreasing for tighter packing without trimming content
  items.sort((a, b) => b.size - a.size);
  const batches = [];

  items.forEach(item => {
    let placed = false;
    for (const batch of batches) {
      const extra = (batch.items.length ? BATCH_SEPARATOR.length : 0) + item.size;
      if (batch.size + extra <= MAX_BATCH_CHARS) {
        batch.items.push(item);
        batch.size += extra;
        batch.tweetUrls.push(...item.tweetUrls);
        placed = true;
        break;
      }
    }
    if (!placed) {
      batches.push({
        items: [item],
        size: promptChars + item.size,
        tweetUrls: [...item.tweetUrls],
      });
    }
  });

  return batches.map(b => ({
    text: b.items.map(i => i.text).join(BATCH_SEPARATOR),
    tweetUrls: [...new Set(b.tweetUrls)],
    accounts: b.items.map(i => i.account),
    size: b.size,
  }));
}

function groupSignalsByTweet(signals) {
  const map = new Map();
  signals.forEach(s => {
    const url = s.tweet_url;
    if (!url) return;
    if (!map.has(url)) map.set(url, []);
    map.get(url).push(s);
  });
  return map;
}

function dedupeSignals(signals) {
  const seen = new Set();
  return signals.filter(s => {
    const key = `${s.tweet_url || ''}|${s.title || ''}|${s.summary || ''}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

async function analyzeWithBatching(accountData, totalTweets, onProgress, promptHash, cache, signal = null) {
  const prompt = getPrompt();
  const promptChars = prompt.length;

  const batches = buildBatches(accountData, promptChars);
  console.log(`Analysis batches: ${batches.length} (${accountData.length} accounts)`);
  if (!batches.length) return [];

  const allSignals = [];
  const results = [];
  let nextIndex = 0;
  const concurrency = Math.min(ANALYSIS_CONCURRENCY, batches.length);

  async function runBatchWorker() {
    while (true) {
      // Check for abort before processing batch
      if (signal?.aborted) throw new DOMException('Scan cancelled', 'AbortError');
      
      const i = nextIndex++;
      if (i >= batches.length) break;

      const batch = batches[i];
      const batchNum = i + 1;
      if (batches.length > 1) {
        onProgress?.(`Analyzing batch ${batchNum}/${batches.length}`);
      } else {
        onProgress?.(`${totalTweets} tweets fetched · Analyzing`);
      }

      const batchContent = sanitizeText(`${prompt}\n\n${batch.text}`);
      try {
        const data = await anthropicCall({
          model: ANALYSIS_MODEL,
          max_tokens: 16384,
          messages: [{ role: 'user', content: batchContent }],
        }, 5, signal);

        const txt = extractText(data.content);
        logs.push({ a: `_batch${batchNum}`, len: txt.length, pre: txt.slice(0, 400) });

        const batchSignals = safeParseSignals(txt);
        if (batchSignals.length > 0) {
          console.log(`Batch ${batchNum}: ${batchSignals.length} signals parsed`);
        } else {
          console.warn(`Batch ${batchNum}: No signals extracted`);
          logs.push({ a: `_parse_warn_${batchNum}`, len: 0, pre: 'No signals extracted from response' });
        }

        results.push({ i, signals: batchSignals, tweetUrls: batch.tweetUrls });
      } catch (e) {
        console.error(`Batch ${batchNum} analysis error:`, e);
        throw e;
      }
    }
  }

  await Promise.all(Array.from({ length: concurrency }, () => runBatchWorker()));
  results.sort((a, b) => a.i - b.i);

  results.forEach(res => {
    allSignals.push(...res.signals);
    const grouped = groupSignalsByTweet(res.signals);
    res.tweetUrls.forEach(url => {
      setCachedSignals(cache, promptHash, url, grouped.get(url) || []);
    });
  });

  return allSignals;
}

// --- Main flow ---
let lastRunTime = 0;
async function run() {
  // Debounce - prevent rapid repeated calls
  const now = Date.now();
  if (now - lastRunTime < 1000) return;
  lastRunTime = now;
  
  const accounts = getAllAccounts();
  if (!accounts.length || busy) return;
  if (!bothKeys()) { openModal(); return; }

  // Setup abort controller for this scan
  abortCurrentScan();
  currentScanAbort = new AbortController();

  setLoading(true);
  $('notices').innerHTML = '';
  $('tweetCount').innerHTML = '';
  $('tickerBar').innerHTML = '';
  $('scanActions').innerHTML = '';
  $('filterBar').innerHTML = '';
  $('results').innerHTML = '';
  logs = [];
  
  // Save custom accounts to recents
  if (customAccounts.length) {
    addToRecents(customAccounts);
    renderSuggested();
  }

  const days = RANGES[range].days;

  const signal = currentScanAbort?.signal;
  
  try {
    // Step 1: Fetch tweets
    const accountTweets = await fetchAllTweets(accounts, days, (msg) => setStatus(msg, true), signal);

    // Tally results
    const totalTweets = accountTweets.reduce((s, a) => s + a.tweets.length, 0);
    const fails = accountTweets.filter(a => a.error);
    const empties = accountTweets.filter(a => !a.error && !a.tweets.length);

    // Build debug logs
    for (const a of accountTweets) {
      logs.push({
        a: a.account,
        len: a.tweets.length,
        pre: a.error
          ? `ERROR: ${a.error}`
          : a.tweets.slice(0, 3).map(t => t.text?.slice(0, 100)).join(' | ') || '(no tweets in range)',
      });
    }

    // Handle no tweets case
    if (totalTweets === 0) {
      let msg = 'no tweets found for this time range';
      if (fails.length) msg += ` — errors: ${fails.map(f => `${f.account} (${f.error})`).join(', ')}`;
      $('notices').innerHTML = `<div class="notice err">${esc(msg)}</div>`;
      setLoading(false); setStatus(''); renderDebug(); return;
    }

    // Show warnings for partial failures
    const parts = [];
    if (fails.length) parts.push(`<span style="color:var(--red)">errors: ${esc(fails.map(f => f.account).join(', '))}</span>`);
    if (parts.length) $('notices').innerHTML = `<div class="notice warn">${parts.join(' · ')}</div>`;

    // Step 2: Analyze with Claude (with caching)
    const accountData = accountTweets.filter(a => a.tweets.length);
    const promptHash = getPromptHash();
    const analysisCache = loadAnalysisCache();
    let cachedSignals = [];
    let cachedTweetCount = 0;

    const uncachedAccountData = accountData.map(a => {
      const uncachedTweets = [];
      (a.tweets || []).forEach(tw => {
        const url = getTweetUrl(tw);
        const cached = getCachedSignals(analysisCache, promptHash, url);
        if (cached) {
          cachedTweetCount++;
          cachedSignals.push(...cached);
        } else {
          uncachedTweets.push(tw);
        }
      });
      return { account: a.account, tweets: uncachedTweets };
    }).filter(a => a.tweets.length);


    let signals = [];
    if (uncachedAccountData.length) {
      const newSignals = await analyzeWithBatching(uncachedAccountData, totalTweets, (msg) => setStatus(msg, true), promptHash, analysisCache, signal);
      signals = dedupeSignals([...cachedSignals, ...newSignals]);
    } else {
      setStatus(`${totalTweets} tweets fetched · Using cache`, false, true);
      signals = dedupeSignals(cachedSignals);
    }

    pruneCache(analysisCache);
    saveAnalysisCache(analysisCache);

    // Store scan result
    lastScanResult = {
      date: new Date().toISOString(),
      range: RANGES[range].label,
      days: RANGES[range].days,
      accounts: [...accounts],
      totalTweets,
      signals,
      rawTweets: accountTweets.map(a => ({ account: a.account, tweets: a.tweets })),
    };
    saveScan(lastScanResult);

    // Update status to final count with full info
    const d = new Date();
    const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    setStatus(`${dateStr} · <span class="hide-mobile">${accounts.length} accounts · ${totalTweets} tweets · </span>${signals.length} signals`, false, true);

    renderTickers(signals);
    renderSignals(signals);
    renderDebug();
    
  } catch (e) {
    if (e.name === 'AbortError') {
      setStatus('Scan cancelled');
    } else {
      setStatus(''); // Clear analyzing status
      $('notices').innerHTML = `<div class="notice err">${esc(e.message)}</div>`;
    }
    renderDebug();
  } finally {
    setLoading(false);
    currentScanAbort = null;
  }
}

// --- Scan Storage ---
// Create a lightweight version for storage (no full tweet content)
function createStorableScan(scan) {
  // Only store essential tweet metadata for tooltips, not full tweet objects
  const tweetMeta = {};
  if (scan.rawTweets) {
    scan.rawTweets.forEach(a => {
      (a.tweets || []).forEach(tw => {
        const url = getTweetUrl(tw);
        tweetMeta[url] = {
          text: (tw.text || '').slice(0, 500), // Truncate long tweets
          author: a.account,
          time: tw.createdAt
        };
      });
    });
  }
  
  return {
    date: scan.date,
    range: scan.range,
    days: scan.days,
    accounts: scan.accounts,
    totalTweets: scan.totalTweets,
    signals: scan.signals,
    tweetMeta // Much smaller than rawTweets
  };
}

function saveScan(scan) {
  try {
    const storable = createStorableScan(scan);
    
    // Save current scan
    localStorage.setItem(LS_CURRENT, JSON.stringify(storable));
    
    // Update history (keep only last 5 to save space)
    const history = JSON.parse(localStorage.getItem(LS_SCANS) || '[]');
    // Build tweet time lookup
    const tweetTimes = {};
    if (scan.rawTweets) {
      scan.rawTweets.forEach(a => {
        (a.tweets || []).forEach(tw => {
          const url = getTweetUrl(tw);
          if (tw.createdAt) tweetTimes[url] = tw.createdAt;
        });
      });
    }
    // Store signals with timestamps
    const historyEntry = {
      date: scan.date,
      range: scan.range,
      accounts: scan.accounts.length,
      totalTweets: scan.totalTweets,
      signalCount: scan.signals.length,
      signals: scan.signals.map(s => ({
        ...s,
        tweet_time: tweetTimes[s.tweet_url] || null
      }))
    };
    history.unshift(historyEntry);
    if (history.length > 5) history.pop();
    localStorage.setItem(LS_SCANS, JSON.stringify(history));
    renderHistory();
  } catch (e) {
    console.warn('Failed to save scan to localStorage:', e.message);
    // Clear old data and try again
    try {
      localStorage.removeItem(LS_SCANS);
      localStorage.setItem(LS_CURRENT, JSON.stringify(createStorableScan(scan)));
    } catch (e2) {
      console.error('Storage quota exceeded, clearing storage');
      localStorage.removeItem(LS_CURRENT);
      localStorage.removeItem(LS_SCANS);
    }
  }
}

function loadCurrentScan() {
  const saved = localStorage.getItem(LS_CURRENT);
  if (!saved) return null;
  try { return JSON.parse(saved); } catch { return null; }
}

function getScanHistory() {
  return JSON.parse(localStorage.getItem(LS_SCANS) || '[]');
}

function downloadLastScan() {
  if (!lastScanResult) return;
  
  // Build tweet lookup for original text
  const tweetText = {};
  if (lastScanResult.rawTweets) {
    lastScanResult.rawTweets.forEach(a => {
      (a.tweets || []).forEach(tw => {
        const url = getTweetUrl(tw);
        tweetText[url] = tw.text || '';
      });
    });
  } else if (lastScanResult.tweetMeta) {
    Object.entries(lastScanResult.tweetMeta).forEach(([url, meta]) => {
      tweetText[url] = meta.text || '';
    });
  }
  
  // Generate Markdown
  const d = new Date(lastScanResult.date);
  const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  
  let md = `# Trading Signals\n\n`;
  md += `**Date:** ${dateStr}\n`;
  md += `**Range:** ${lastScanResult.range}\n`;
  md += `**Accounts:** ${lastScanResult.accounts.length}\n`;
  md += `**Signals:** ${lastScanResult.signals.length}\n\n---\n\n`;
  
  lastScanResult.signals.forEach((s, i) => {
    const cat = normCat(s.category);
    const tickers = (s.tickers || []).map(t => `${t.symbol} (${t.action})`).join(', ');
    const tweet = tweetText[s.tweet_url] || '';
    const links = (s.links || []).length ? s.links.join(', ') : '';
    
    md += `## ${s.title}\n\n`;
    md += `${s.summary}\n\n`;
    if (tickers) md += `**Tickers:** ${tickers}\n`;
    md += `**Category:** ${cat}\n`;
    md += `**Source:** @${s.source}\n`;
    if (tweet) md += `**Tweet:** "${tweet}"\n`;
    if (links) md += `**Links:** ${links}\n`;
    if (i < lastScanResult.signals.length - 1) md += `\n---\n\n`;
  });
  
  const date = new Date(lastScanResult.date).toISOString().slice(0, 16).replace('T', '-').replace(':', '');
  const blob = new Blob([md], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `sentry-${date}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// --- Renderers ---
function tickerUrl(sym) {
  const s = sym.replace(/^\$/, '').toUpperCase();
  if (getFinanceProvider() === 'google') {
    // Google Finance needs exchange, try to infer from suffix
    if (s.endsWith('.TW')) return `https://www.google.com/finance/quote/${s.replace('.TW', '')}:TPE?window=6M`;
    if (s.endsWith('.HK')) return `https://www.google.com/finance/quote/${s.replace('.HK', '')}:HKG?window=6M`;
    if (s.endsWith('.T')) return `https://www.google.com/finance/quote/${s.replace('.T', '')}:TYO?window=6M`;
    if (s.endsWith('.KS')) return `https://www.google.com/finance/quote/${s.replace('.KS', '')}:KRX?window=6M`;
    return `https://www.google.com/finance/quote/${s}?window=6M`;
  }
  return `https://finance.yahoo.com/quote/${encodeURIComponent(s)}`;
}

function renderTickers(signals) {
  const map = {};
  signals.forEach(r => (r.tickers || []).forEach(t => {
    const k = (t.symbol || '').toUpperCase();
    if (!k) return;
    if (!map[k]) map[k] = { s: k, acts: new Set(), n: 0 };
    map[k].acts.add(t.action); map[k].n++;
  }));
  const list = Object.values(map).sort((a, b) => b.n - a.n);
  const el = $('tickerBar');
  if (!list.length) { el.innerHTML = ''; el.className = ''; return; }
  el.className = 'ticker-bar';
  el.innerHTML = list.map(t => {
    // If both buy and sell, show "mixed"
    const hasBuy = t.acts.has('buy');
    const hasSell = t.acts.has('sell');
    const pa = (hasBuy && hasSell) ? 'mixed' : ['sell', 'buy', 'hold', 'watch'].find(a => t.acts.has(a)) || 'watch';
    const url = tickerUrl(t.s);
    return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="ticker-item" style="color:${ACT_C[pa]};background:${ACT_BG[pa]}">${esc(t.s)}${t.n > 1 ? `<span class="ticker-cnt">×${t.n}</span>` : ''}</a>`;
  }).join('');
}

function renderScanActions() {
  $('scanActions').innerHTML = '';
}

function renderSignals(signals) {
  const el = $('results');
  filters = { category: null }; // reset filters
  if (!signals.length) { el.innerHTML = '<div class="empty-state">No signals extracted</div>'; renderScanActions(); renderFilters(); $('footer').innerHTML = ''; return; }
  
  // Build tweet URL to info map from rawTweets or tweetMeta
  const tweetMap = {};
  if (lastScanResult?.rawTweets) {
    // Full data available (current session)
    lastScanResult.rawTweets.forEach(a => {
      (a.tweets || []).forEach(tw => {
        const url = getTweetUrl(tw);
        const date = tw.createdAt ? new Date(tw.createdAt) : null;
        const timeStr = date ? date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
        tweetMap[url] = {
          text: tw.text || '',
          author: tw.author?.userName || a.account || '',
          time: timeStr
        };
      });
    });
  } else if (lastScanResult?.tweetMeta) {
    // Loaded from storage (lighter format)
    Object.entries(lastScanResult.tweetMeta).forEach(([url, meta]) => {
      const date = meta.time ? new Date(meta.time) : null;
      const timeStr = date ? date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
      tweetMap[url] = {
        text: meta.text || '',
        author: meta.author || '',
        time: timeStr
      };
    });
  }
  
  let h = '';
  signals.forEach((item, i) => {
    const cat = normCat(item.category);
    const tweetInfo = item.tweet_url ? (tweetMap[item.tweet_url] || {}) : {};
    const source = (item.source || '').replace(/^@/, '');
    const time = tweetInfo.time || '';
    
    const tickers = (item.tickers && item.tickers.length)
      ? item.tickers.map(t => {
          const url = tickerUrl(t.symbol || '');
          return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="ticker-tag" style="color:${ACT_C[t.action] || 'var(--text-muted)'};background:${ACT_BG[t.action] || 'var(--text-10)'}">${esc(t.symbol)}</a>`;
        }).join('')
      : '';
    
    const extLinks = (item.links && item.links.length)
      ? item.links.map(l => {
          try {
            const hostname = new URL(l).hostname.replace('www.','');
            return `<a href="${esc(l)}" target="_blank" rel="noopener noreferrer" class="ext-link">${esc(hostname)}</a>`;
          } catch { return ''; }
        }).filter(Boolean).join(' ')
      : '';
    
    const sourceLink = item.tweet_url 
      ? `<a href="${esc(item.tweet_url)}" target="_blank" rel="noopener noreferrer" data-tweet="${esc(tweetInfo.text || '')}" data-author="${esc(source)}" data-time="${esc(time)}">@${esc(source)}</a>`
      : `@${esc(source)}`;
    
    const seePost = item.tweet_url
      ? `<a href="${esc(item.tweet_url)}" target="_blank" rel="noopener noreferrer" class="see-post" data-tweet="${esc(tweetInfo.text || '')}" data-author="${esc(source)}" data-time="${esc(time)}"><span class="text">See post</span><span class="arrow">↗</span></a>`
      : '';
    
    h += `<div class="signal" data-category="${esc(cat || '')}">
      <div class="sig-top"><span>${sourceLink}${time ? ` · ${time}` : ''}${cat ? ` · <span class="sig-cat">${esc(cat)}</span>` : ''}</span>${seePost}</div>
      ${tickers ? `<div class="sig-tickers">${tickers}</div>` : ''}
      <div class="sig-title">${esc(item.title || '')}</div>
      <div class="sig-summary">${esc(item.summary || '')}</div>
      ${extLinks ? `<div class="sig-links">${extLinks}</div>` : ''}
    </div>`;
  });
  el.innerHTML = h;
  renderScanActions();
  renderFilters();
  $('footer').innerHTML = 'Not financial advice';
  setupTweetTooltips();
}

function setupTweetTooltips() {
  const tooltip = $('tweetTooltip');
  document.querySelectorAll('.see-post[data-tweet]').forEach(link => {
    link.addEventListener('mouseenter', e => {
      const text = link.dataset.tweet;
      if (!text) return;
      const author = link.dataset.author || '';
      const time = link.dataset.time || '';
      const header = (author || time) ? `<div style="opacity:.7;margin-bottom:8px">@${esc(author)} · ${esc(time)}</div>` : '';
      tooltip.innerHTML = header + esc(text);
      tooltip.classList.add('vis');
    });
    link.addEventListener('mousemove', e => {
      const x = e.clientX + 12;
      const y = e.clientY + 12;
      // Keep tooltip in viewport
      const rect = tooltip.getBoundingClientRect();
      const maxX = window.innerWidth - rect.width - 20;
      const maxY = window.innerHeight - rect.height - 20;
      tooltip.style.left = Math.min(x, maxX) + 'px';
      tooltip.style.top = Math.min(y, maxY) + 'px';
    });
    link.addEventListener('mouseleave', () => {
      tooltip.classList.remove('vis');
    });
  });
}

function renderHistory() {
  const el = $('historySection');
  const history = getScanHistory();
  if (!history.length) { el.innerHTML = ''; return; }
  
  let h = '<div class="history">';
  history.forEach((scan, i) => {
    const d = new Date(scan.date);
    const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    const label = `Scan ${dateStr}`;
    const range = scan.range || '—';
    const accounts = Number.isFinite(scan.accounts) ? scan.accounts : '—';
    const tweets = Number.isFinite(scan.totalTweets) ? scan.totalTweets : '—';
    const signals = Number.isFinite(scan.signalCount) ? scan.signalCount : '—';
    const details = `Range: ${esc(range)} · Accounts: ${accounts} · Tweets: ${tweets} · Signals: ${signals}`;
    const cards = (scan.signals && scan.signals.length)
      ? scan.signals.map(item => {
          const cat = normCat(item.category);
          const tickers = (item.tickers && item.tickers.length)
            ? item.tickers.map(t => {
                const url = tickerUrl(t.symbol || '');
                return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="ticker-tag" style="color:${ACT_C[t.action] || 'var(--text-muted)'};background:${ACT_BG[t.action] || 'var(--text-10)'}">${esc(t.symbol)}</a>`;
              }).join('')
            : '';
          const source = (item.source || '').replace(/^@/, '');
          const sourceLink = item.tweet_url
            ? `<a href="${esc(item.tweet_url)}" target="_blank" rel="noopener noreferrer">@${esc(source)}</a>`
            : `@${esc(source)}`;
          const tweetTime = item.tweet_time ? new Date(item.tweet_time) : null;
          const timeStr = tweetTime ? tweetTime.toLocaleDateString() + ' ' + tweetTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
          const extLinks = (item.links && item.links.length)
            ? item.links.map(l => {
                try {
                  const hostname = new URL(l).hostname.replace('www.','');
                  return `<a href="${esc(l)}" target="_blank" rel="noopener noreferrer" class="ext-link">${esc(hostname)}</a>`;
                } catch { return ''; }
              }).filter(Boolean).join(' ')
            : '';
          return `<div class="signal" data-category="${esc(cat || '')}">
            <div class="sig-top"><span>${sourceLink}${timeStr ? ` · ${timeStr}` : ''}${cat ? ` · <span class="sig-cat">${esc(cat)}</span>` : ''}</span></div>
            ${tickers ? `<div class="sig-tickers">${tickers}</div>` : ''}
            <div class="sig-title">${esc(item.title || '')}</div>
            <div class="sig-summary">${esc(item.summary || '')}</div>
            ${extLinks ? `<div class="sig-links">${extLinks}</div>` : ''}
          </div>`;
        }).join('')
      : '<div class="empty-state">No signals in this scan</div>';
    h += `<div class="hist-item" data-index="${i}">
      <div class="hist-header">
        <button class="hist-toggle" data-label="${esc(label)}">▸ ${esc(label)}</button>
        <div class="hist-actions">
          <button class="delete" title="Delete">×</button>
          <button class="download" title="Download">↓</button>
        </div>
      </div>
      <div class="hist-body"><div class="hist-meta">${details}</div><div class="hist-cards">${cards}</div></div>
    </div>`;
  });
  h += '</div>';
  el.innerHTML = h;
  
  el.querySelectorAll('.hist-toggle').forEach(btn => {
    btn.addEventListener('click', () => {
      const item = btn.closest('.hist-item');
      const open = item.classList.toggle('open');
      const label = btn.dataset.label || btn.textContent.replace(/^▸\s|^▾\s/, '');
      btn.textContent = (open ? '▾ ' : '▸ ') + label;
    });
  });
  
  el.querySelectorAll('.hist-actions .download').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const index = parseInt(btn.closest('.hist-item').dataset.index);
      downloadHistoryScan(index);
    });
  });
  
  el.querySelectorAll('.hist-actions .delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const index = parseInt(btn.closest('.hist-item').dataset.index);
      deleteHistoryScan(index);
    });
  });
}

function downloadHistoryScan(index) {
  const history = getScanHistory();
  const scan = history[index];
  if (!scan) return;
  
  // Generate Markdown
  const d = new Date(scan.date);
  const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  
  let md = `# Trading Signals\n\n`;
  md += `**Date:** ${dateStr}\n`;
  md += `**Range:** ${scan.range || '—'}\n`;
  md += `**Accounts:** ${scan.accounts || '—'}\n`;
  md += `**Signals:** ${scan.signalCount || (scan.signals?.length || 0)}\n\n---\n\n`;
  
  (scan.signals || []).forEach((s, i) => {
    const cat = normCat(s.category);
    const tickers = (s.tickers || []).map(t => `${t.symbol} (${t.action})`).join(', ');
    const links = (s.links || []).length ? s.links.join(', ') : '';
    
    md += `## ${s.title}\n\n`;
    md += `${s.summary}\n\n`;
    if (tickers) md += `**Tickers:** ${tickers}\n`;
    md += `**Category:** ${cat}\n`;
    md += `**Source:** @${s.source}\n`;
    if (links) md += `**Links:** ${links}\n`;
    if (i < scan.signals.length - 1) md += `\n---\n\n`;
  });
  
  const date = new Date(scan.date).toISOString().slice(0, 16).replace('T', '-').replace(':', '');
  const blob = new Blob([md], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `sentry-${date}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function deleteHistoryScan(index) {
  const history = getScanHistory();
  if (index < 0 || index >= history.length) return;
  history.splice(index, 1);
  localStorage.setItem(LS_SCANS, JSON.stringify(history));
  renderHistory();
}

function renderDebug() {}

// --- Filters ---
function setFilter(type, value) {
  filters[type] = filters[type] === value ? null : value;
  applyFilters();
  renderFilters();
}

function applyFilters() {
  const rows = document.querySelectorAll('#results .signal');
  rows.forEach(row => {
    const cat = row.dataset.category;
    const catMatch = !filters.category || cat === filters.category;
    row.classList.toggle('hidden', !catMatch);
  });
}

function renderFilters() {
  const el = $('filterBar');
  if (!lastScanResult || !lastScanResult.signals.length) { el.innerHTML = ''; return; }
  
  let h = '<div class="filter-bar">';
  CATEGORIES.forEach(c => {
    const on = filters.category === c ? ' on' : '';
    h += `<button class="rng${on}" onclick="setFilter('category','${c}')">${c}</button>`;
  });
  h += '</div>';
  el.innerHTML = h;
}

// ============================================================================
// INITIALIZATION
// ============================================================================

// Initialize app
(function init() {
  // Apply settings
  setTheme(getTheme());
  setFont(getFont());
  setFontSize(getFontSize());
  setCase(getCase());
  
  // Load user data
  loadAccountsData();
  loadLoadedPresets();
  
  // Cleanup old cache entries
  cleanupCache();
  
  // Render UI
  render();
  renderHistory();

  // Load previous scan on refresh
  const savedScan = loadCurrentScan();
  if (savedScan) {
    lastScanResult = savedScan;
    const d = new Date(savedScan.date);
    const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    setStatus(`${dateStr} · <span class="hide-mobile">${savedScan.accounts.length} accounts · ${savedScan.totalTweets} tweets · </span>${savedScan.signals.length} signals`, false, true);
    renderTickers(savedScan.signals);
    renderSignals(savedScan.signals);
  }
  
  // Register service worker for PWA
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').catch(() => {});
  }
  
  console.log('✓ Sentry initialized');
})();
</script>
</body>
</html>