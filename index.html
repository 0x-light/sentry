<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>sentry</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #ffffff; --bg-alt: #f5f5f5; --text: #555; --text-strong: #222; --text-strong-rgb: 34,34,34; --text-muted: #999;
  --text-10: rgba(85,85,85,0.1); --text-20: rgba(85,85,85,0.2);
  --border: #eee; --border-light: #f5f5f5; --chip-bg: transparent; --chip-border: #ddd;
  --green: #1a7a1a; --green-10: rgba(26,122,26,0.1);
  --red: #cc2222; --red-10: rgba(204,34,34,0.1);
  --blue: #2255bb; --blue-10: rgba(34,85,187,0.1);
  --purple: #7733aa; --purple-10: rgba(119,51,170,0.1);
  --amber: #996600; --amber-10: rgba(153,102,0,0.1);
}
[data-theme="dark"] {
  --bg: #0a0a0a; --bg-alt: #151515; --text: #888; --text-strong: #ddd; --text-strong-rgb: 221,221,221; --text-muted: #555;
  --text-10: rgba(136,136,136,0.1); --text-20: rgba(136,136,136,0.2);
  --border: #222; --border-light: #1a1a1a; --chip-bg: #151515; --chip-border: #333;
  --green: #4ade80; --green-10: rgba(74,222,128,0.1);
  --red: #ff4b4b; --red-10: rgba(248,113,113,0.1);
  --blue: #60a5fa; --blue-10: rgba(96,165,250,0.1);
  --purple: #a78bfa; --purple-10: rgba(167,139,250,0.1);
  --amber: #fbbf24; --amber-10: rgba(251,191,36,0.1);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg); color: var(--text);
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 13px; -webkit-font-smoothing: antialiased;
}
[data-font="system"], [data-font="system"] * {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
/* Text case - default is lowercase */
/* Lowercase mode - UI elements only */
[data-case="lower"] .logo-text, [data-case="lower"] .top-btn, [data-case="lower"] .add-btn,
[data-case="lower"] .preset-btn, [data-case="lower"] .preset-manage, [data-case="lower"] .sug,
[data-case="lower"] .rng, [data-case="lower"] .chip, [data-case="lower"] .chip-summary, 
[data-case="lower"] .chip-header, [data-case="lower"] .chip-x, [data-case="lower"] .clear-btn,
[data-case="lower"] .scan-btn, [data-case="lower"] .sig-cat,
[data-case="lower"] .debug-toggle, [data-case="lower"] .dl-btn, [data-case="lower"] .footer,
[data-case="lower"] .empty-state, [data-case="lower"] .see-post, [data-case="lower"] .modal h3, [data-case="lower"] label,
[data-case="lower"] .modal-actions button, [data-case="lower"] .preset-list-item button,
[data-case="lower"] input::placeholder, [data-case="lower"] textarea::placeholder { text-transform: lowercase; }
::selection { background: var(--bg-alt); color: var(--green); }
input::placeholder { color: var(--text-muted); }
button { font-family: inherit; cursor: pointer; }

.topbar {
  padding: 20px; border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
}
.logo { display: flex; align-items: center; gap: 8px; }
.dot { font-size: 8px; color: var(--text-strong); line-height: 1; }
.dot.loading { animation: pulse 0.6s infinite; }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
.logo-text { font-size: 13px; font-weight: 500; color: var(--text-strong); }
.topbar-right { display: flex; align-items: center; gap: 16px; }
.top-btn { background: none; border: none; font-size: 13px; color: var(--text-muted); padding: 3px 6px; }
.top-btn:hover { color: var(--text); }
.top-btn.warn { color: var(--amber); }

/* modal */
.modal-bg {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,.5); z-index: 100;
  align-items: center; justify-content: center; padding: 16px;
}
.modal-bg.open { display: flex; }
.modal {
  background: var(--bg); border: 1px solid var(--border);
  padding: 24px; width: 100%; max-width: 420px; max-height: calc(100vh - 32px); overflow-y: auto;
  position: relative;
}
.modal-close { position: absolute; top: 16px; right: 16px; background: none; border: none; color: var(--text-muted); font-size: 18px; cursor: pointer; padding: 4px 8px; line-height: 1; }
.modal-close:hover { color: var(--text-strong); }
.modal h3 { font-size: 15px; font-weight: 500; color: var(--text-strong); margin-bottom: 8px; }
.modal p { font-size: 13px; color: var(--text-muted); margin-bottom: 24px; line-height: 1.6; }
.modal p a { color: var(--blue); text-decoration: none; }
.modal p a:hover { text-decoration: underline; }
.modal label { display: block; font-size: 11px; color: var(--text-muted); margin-bottom: 6px; margin-top: 16px; text-transform: uppercase; }
.modal label:first-of-type { margin-top: 0; }
.reset-prompt { background: none; border: none; color: var(--text-muted); font-size: 11px; cursor: pointer; margin-left: 8px; text-transform: lowercase; }
.reset-prompt:hover { color: var(--text-strong); }
.modal input, .modal select, .modal textarea {
  width: 100%; border: 1px solid var(--chip-border); padding: 10px 12px;
  font-family: inherit; font-size: inherit; color: var(--text-strong); outline: none;
  background: var(--bg); resize: vertical;
}
.modal select {
  padding-right: 36px; cursor: pointer;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
}
[data-theme="dark"] .modal select {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23999' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
}
.modal input:focus, .modal textarea:focus { border-color: var(--text-muted); }
.modal-actions { display: flex; gap: 8px; margin-top: 24px; justify-content: flex-end; }
.modal-actions button {
  background: none; border: 1px solid var(--chip-border);
  font-size: 13px; padding: 3px 6px; color: var(--text);
}
.modal-actions button:hover { border-color: var(--text-muted); color: var(--text-strong); }
.modal-actions button:last-child { background: var(--text-strong); border-color: var(--text-strong); color: var(--bg); }
.modal-actions button:last-child:hover { opacity: 0.9; }
.modal-actions button.danger { color: var(--red); margin-right: auto; }
.modal-actions button.danger:hover { border-color: var(--red); }
.preset-list { margin-top: 24px; border-top: 1px solid var(--border); padding-top: 16px; }
.preset-list-item {
  display: flex; align-items: center; justify-content: space-between; padding: 10px 0;
  border-bottom: 1px solid var(--border-light); font-size: 13px;
}
.preset-list-item:last-child { border-bottom: none; }
.preset-list-item span { color: var(--text-strong); }
.preset-list-item small { color: var(--text-muted); margin-left: 8px; font-size: 12px; }
.preset-list-item.editing { background: var(--bg-alt); margin: 0 -8px; padding: 10px 8px; }
.preset-list-actions { display: flex; gap: 8px; }
.preset-list-item button { background: none; border: none; color: var(--text-muted); font-size: 12px; padding: 4px 0; }
.preset-list-item button:hover { color: var(--text-strong); }
.preset-list-item button.danger:hover { color: var(--red); }

.controls { padding: 20px; border-bottom: 1px solid var(--border); }
.input-row { display: flex; gap: 6px; align-items: center; margin-bottom: 20px; }
.input-row .at { color: var(--text-muted); font-size: 13px; }
.input-row input {
  flex: 1; background: transparent; border: none; outline: none;
  color: var(--text-strong); font-size: inherit; font-family: inherit;
}
.add-btn { background: none; border: none; color: var(--text-muted); font-size: 13px; padding: 3px 6px; display: none; }
.add-btn.vis { display: inline; }

.presets-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 20px; }
.preset-btn {
  background: none; border: 1px solid var(--chip-border);
  color: var(--text-muted); font-size: 13px; padding: 3px 6px;
}
.preset-btn:hover { color: var(--text-strong); border-color: var(--text-muted); }
.preset-btn.active { color: var(--text-strong); border-color: var(--text-strong); }
.preset-manage { background: none; border: none; color: var(--text-muted); font-size: 13px; padding: 3px 6px; }
.preset-manage:hover { color: var(--text-strong); }

.suggested { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; margin-bottom: 20px; }
.suggested:empty { margin-bottom: 0; }
.sug { background: none; border: none; color: var(--text-muted); font-size: 13px; }
.sug:hover { color: var(--text-strong); }
.sug.used { opacity: .35; cursor: default; }

.ranges { display: flex; gap: 16px; align-items: center; }
.ranges.mb { margin-bottom: 20px; }
.rng {
  background: none; border: none; border-bottom: 1px solid transparent;
  color: var(--text-muted); font-size: 13px;
}
.rng:hover { color: var(--text-strong); }
.rng.on { color: var(--text-strong); border-bottom-color: var(--text-strong); }

.chips { display: none; align-items: center; gap: 8px; flex-wrap: wrap; }
.chips.vis { display: flex; }
.chip {
  font-size: 13px; color: var(--text-strong); background: var(--bg-alt); border: 1px solid var(--bg-alt);
  padding: 3px 6px; display: inline-flex; align-items: center; gap: 6px;
}
.chip-group.expanded .chip { border-color: rgba(var(--text-strong-rgb), 0.1); }
.chip .x { cursor: pointer; color: var(--text-muted); font-size: 10px; }
.chip-group { display: inline-flex; align-items: center; gap: 4px; margin-right: 4px; background: var(--bg-alt); }
.chip-group.expanded { flex-wrap: wrap; }
.chip-summary { cursor: pointer; color: var(--text-strong); border: none; background: none; padding: 3px 0 3px 6px; }
.chip-count { color: var(--text-muted); font-size: 13px; }
.chip-header { cursor: pointer; color: var(--text-strong); border: none; background: none; padding: 3px 6px; font-size: 13px; }
.chip-x { background: none; border: none; color: var(--text-muted); font-size: 10px; padding: 2px 6px 2px 0px; cursor: pointer; }
.chip-x:hover { color: var(--red); }
.clear-btn { background: none; border: none; color: var(--text-muted); font-size: 13px; padding: 3px 6px; }
.clear-btn:hover { color: var(--red); }
.scan-btn {
  margin-left: auto; background: var(--text-strong); border: 1px solid var(--text-strong); color: var(--bg); font-size: 13px; padding: 3px 6px;
}
.scan-btn:hover:not(:disabled) { opacity: .8; }
.scan-btn:disabled { opacity: .5; cursor: default; }

.notice { padding: 12px 20px; font-size: 13px; border-bottom: 1px solid var(--border); }
.notice.err { color: var(--red); }
.notice.warn { color: var(--text-muted); }

.tweet-count { padding: 10px 20px; font-size: 13px; color: var(--text-muted); border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
.tweet-count:empty { display: none; }
.tweet-count .dl-btn { margin-left: auto; }
.dots::after { content: ''; animation: dots 1.2s steps(4, end) infinite; }
@keyframes dots { 0% { content: ''; } 25% { content: '.'; } 50% { content: '..'; } 75% { content: '...'; } }

.ticker-bar {
  padding: 14px 20px; border-bottom: 1px solid var(--border);
  display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
}
.ticker-item { font-size: 13px; display: inline-flex; align-items: center; gap: 4px; white-space: nowrap; text-decoration: none; font-weight: 500; }
.ticker-item:hover { opacity: .7; }
.ticker-cnt { font-size: 11px; opacity: .6; }

.filter-bar {
  padding: 12px 20px; border-bottom: 1px solid var(--border);
  display: flex; gap: 16px; align-items: center; flex-wrap: wrap;
}

.signal {
  padding: 20px; border-bottom: 1px solid var(--border);
}
.signal.hidden { display: none; }
.sig-top { font-size: 13px; color: var(--text-muted); margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
.sig-top a { color: var(--text-muted); text-decoration: none; }
.sig-top a:hover { color: var(--text-strong); }
.sig-tickers { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
.ticker-tag { font-size: 13px; font-weight: 500; text-decoration: none; }
.ticker-tag:hover { opacity: .7; }
.ticker-tag .a { display: none; }
.sig-title { font-size: 14px; color: var(--text-strong); font-weight: 500; line-height: 1.4; margin-bottom: 6px; }
.sig-summary { font-size: 13px; color: var(--text); line-height: 1.55; }
.sig-links { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; }
.ext-link { font-size: 13px; color: var(--text); text-decoration: none; background: var(--text-10); }
.ext-link:hover { background: var(--text-20); }
.sig-bottom { margin-top: 10px; font-size: 11px; color: var(--text-muted); display: flex; align-items: center; gap: 6px; }
.sig-cat { color: inherit; }
.see-post { color: var(--text-muted); text-decoration: none; font-size: 13px; }
.see-post:hover { color: var(--text-strong); }
.see-post .arrow { display: none; }
@media (max-width: 700px) {
  .see-post .text { display: none; }
  .see-post .arrow { display: inline; }
}
.tweet-tooltip {
  position: fixed; z-index: 1000; max-width: 320px; padding: 12px 14px;
  background: var(--text-strong); color: var(--bg); font-size: 13px; line-height: 1.5;
  pointer-events: none; opacity: 0; border: 1px solid var(--text-strong);
}
.tweet-tooltip.vis { opacity: 1; }
.empty-state { padding: 48px 20px; font-size: 13px; color: var(--text-muted); text-align: center; }

.debug-section { padding: 16px 20px; }
.debug-toggle { background: none; border: none; color: var(--text-muted); font-size: 13px; padding: 3px 6px; }
.debug-content { margin-top: 8px; font-size: 13px; color: var(--text-muted); line-height: 1.7; white-space: pre-wrap; display: none; }
.debug-content.open { display: block; }
.debug-entry { margin-bottom: 10px; border-bottom: 1px solid var(--border-light); padding-bottom: 8px; }

.scan-actions { padding: 12px 20px; border-bottom: 1px solid var(--border); display: flex; gap: 12px; align-items: center; }
.scan-actions .meta { font-size: 13px; color: var(--text-muted); flex: 1; }
.dl-btn {
  background: none; border: none;
  color: var(--text-muted); font-size: 13px; padding: 3px 6px; cursor: pointer;
}
.dl-btn:hover { color: var(--text-strong); }

.footer { padding: 20px; font-size: 10px; color: var(--text-muted); }
.footer:empty { display: none; }

@media (max-width: 700px) {
  .topbar, .controls, .notice, .tweet-count, .ticker-bar, .scan-actions, .filter-bar, .signal, .debug-section, .footer {
    padding-left: 16px; padding-right: 16px;
  }
  .hide-mobile { display: none; }
  .modal input, .modal textarea, .modal select, .input-row input { font-size: 16px !important; } /* prevent iOS zoom on focus */
  .modal-bg { align-items: flex-end; padding: 0; }
  .modal { max-width: 100%; max-height: 85vh; border: none; border-top: 1px solid var(--border); padding: 20px; }
  .modal-actions { flex-direction: column-reverse; }
  .modal-actions button { width: 100%; padding: 12px; }
  .modal-actions button.danger { margin-right: 0; margin-top: 8px; }
}
</style>
</head>
<body>

<!-- key modal -->
<div class="modal-bg" id="modal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal()">âœ•</button>
    <h3>Settings</h3>
    <p>Keys are stored in your browser only and are never sent anywhere except to their respective APIs.<br>
    Get an X/Twitter API key at <a href="https://twitterapi.io" target="_blank">twitterapi.io</a>.<br>
    Get an Anthropic API key at <a href="https://platform.claude.com/settings/keys" target="_blank">platform.claude.com</a>.</p>
    <label>Twitter API key (twitterapi.io)</label>
    <input type="password" id="twKeyInput" placeholder="Your twitterapi.io key">
    <label>Anthropic API key</label>
    <input type="password" id="keyInput" placeholder="sk-ant-...">
    <label>Finance charts</label>
    <select id="financeProvider">
      <option value="yahoo">Yahoo Finance</option>
      <option value="google">Google Finance</option>
    </select>
    <label>Font</label>
    <select id="fontProvider">
      <option value="mono">Monospace</option>
      <option value="system">System</option>
    </select>
    <label>Text style</label>
    <select id="caseProvider">
      <option value="lower">lowercase</option>
      <option value="sentence">Sentence case</option>
    </select>
    <label>Analyst prompt <button type="button" class="reset-prompt" onclick="resetPrompt()">reset</button></label>
    <textarea id="promptInput" style="height:150px" placeholder="Custom instructions for the AI analyst..."></textarea>
    <div class="modal-actions">
      <button class="danger" id="clearKeyBtn" onclick="clearKeys()">Clear all</button>
      <button onclick="closeModal()">Cancel</button>
      <button onclick="saveKeys()">Save</button>
    </div>
  </div>
</div>

<!-- preset modal -->
<div class="modal-bg" id="presetModal">
  <div class="modal">
    <button class="modal-close" onclick="closePresetModal()">âœ•</button>
    <h3>Manage presets</h3>
    <p>Create lists of accounts for quick scanning.</p>
    <label>Preset name</label>
    <input type="text" id="presetNameInput" placeholder="E.g. Commodities">
    <label>Accounts (comma-separated)</label>
    <textarea id="presetAccountsInput" style="height:175px" placeholder="account1, account2, account3"></textarea>
    <div class="modal-actions">
      <button onclick="closePresetModal()">Cancel</button>
      <button onclick="savePreset()">Save preset</button>
    </div>
    <div class="preset-list" id="presetList"></div>
  </div>
</div>

<div class="topbar">
  <div class="logo">
    <span class="dot" id="dot">â– </span>
    <span class="logo-text">Sentry</span>
  </div>
  <div class="topbar-right">
    <button class="top-btn" id="themeBtn" onclick="toggleTheme()">Theme</button>
    <button class="top-btn" id="keyBtn" onclick="openModal()">Settings</button>
  </div>
</div>

<div class="controls">
  <div class="input-row">
    <span class="at">@</span>
    <input type="text" id="acctInput" placeholder="Add account" autocomplete="off">
    <button class="add-btn" id="addBtn">Add</button>
  </div>
  <div class="presets-row" id="presetsRow"></div>
  <div class="suggested" id="suggested"></div>
  <div class="ranges" id="rangesRow"></div>
  <div class="chips" id="chipsRow"></div>
</div>

<div id="tweetCount"></div>
<div id="notices"></div>
<div id="tickerBar"></div>
<div id="scanActions"></div>
<div id="filterBar"></div>
<div id="results"></div>
<div id="debugSection"></div>
<div class="footer" id="footer"></div>
<div class="tweet-tooltip" id="tweetTooltip"></div>

<script>
// --- Config ---
const DEFAULT_PRESETS = [
  { name: 'tradfi', accounts: ['ayz_yzyz', 'citrini7', 'jukan05', 'nicholastreece', 'zephyr_z9'] },
  { name: 'crypto', accounts: ['0xaporia', '0xGeeGee', '0xkyle__', '0xNairolf', '__bleeker', 'AggrNews', 'ahboyash', 'awawat', 'BambouClub', 'based16z', 'blknoiz06', 'Bluntz_Capital', 'burstingbagel', 'c0xswain', 'Cbb0fe', 'Cheshire_Cap', 'choffstein', 'chortly', 'chrisgrx_', 'CL207', 'cobie', 'Cryptopathic', 'danny_xbt', 'deaftrader1', 'defi_monk', 'DeFiyst', 'definalist', 'DegenPing', 'delucinator', 'DonAlt', 'Evan_ss6', 'FoftyPawlow', 'gametheorizing', 'goodalexander', 'hansolar21', 'HsakaTrades', 'Husslin_', 'ieaturfoods', 'inversebrah', 'jeff_w1098', 'kwaker_oats_', 'lBattleRhino', 'maruushae', 'mert', 'mlmabc', 'NyuuRoe', 'PaperFlow8', 'pet3rpan_', 'PineAnalytics', 'pk79z', 'QwQiao', 'redphonecrypto', 'riddle245', 'rodeo_crypro', 'RunnerXBT', 'saliencexbt', 'sershokunin', 'TangTrades', 'Techno_Revenant', 'tetra_gamma', 'TheCryptoNexus', 'ThinkingUSD', 'trading_axe', 'TreeNewsFeed', 'tzedonn', 'velo_xyz', 'xmgnr', 'zoomerfied'] },
];
const MAX_RECENTS = 10; // how many recent accounts to show
const RANGES = [
  { label: 'Today', days: 1 },
  { label: 'This week', days: 7 },
  { label: 'This month', days: 30 },
];
const CATEGORIES = ['Trade', 'Tool', 'Insight', 'Resource'];
const CAT_C = { Trade: 'var(--green)', Tool: 'var(--blue)', Insight: 'var(--purple)', Resource: 'var(--amber)' };
// Migrate old category names
const CAT_MIGRATE = { 'Investment Idea': 'Trade', 'Tool / Product': 'Tool' };
function normCat(c) { return CAT_MIGRATE[c] || c; }
const ACT_C = { buy: 'var(--green)', sell: 'var(--red)', hold: 'var(--amber)', watch: 'var(--blue)', mixed: 'var(--purple)' };
const ACT_BG = { buy: 'var(--green-10)', sell: 'var(--red-10)', hold: 'var(--amber-10)', watch: 'var(--blue-10)', mixed: 'var(--purple-10)' };
const LS_TW = 'signal_twitter_key';
const LS_AN = 'signal_anthropic_key';
const LS_SCANS = 'signal_scan_history';
const LS_CURRENT = 'signal_current_scan';
const LS_PROMPT = 'signal_custom_prompt';
const DEFAULT_PROMPT = `You are a world-class financial analyst. Extract actionable trading signals from these tweets. Be thorough â€” every tweet with a tradeable opinion counts.

Return a JSON array. Each signal:
- "title": A compelling, specific headline like a Bloomberg terminal alert. Lead with the ticker/company when relevant. Examples: "NVDA: Supply constraints ease, buy signal", "Nanya, Winbond: Memory supercycle beneficiaries", "AT&S undervalued despite momentum". NO generic titles.
- "summary": 1-2 punchy sentences with the core thesis and reasoning. Be specific about why.
- "category": "Trade" | "Tool" | "Insight" | "Resource"
- "source": twitter handle (no @)
- "tickers": [{symbol: "$TICKER", action: "buy"|"sell"|"hold"|"watch"}] â€” Extract ALL tickers mentioned. Use Yahoo Finance format: US stocks just the symbol (e.g. "$AAPL", "$UBER"), Taiwan add .TW (e.g. "$2408.TW"), Hong Kong add .HK, Japan add .T, Korea add .KS, crypto just symbol (e.g. "$BTC").
- "tweet_url": exact tweet_url from data
- "links": external URLs mentioned (articles, substacks). Empty array if none.

Return ONLY valid JSON array. No markdown, no explanation.`;
const LS_ACCOUNTS = 'signal_accounts';
const LS_LOADED_PRESETS = 'signal_loaded_presets';
const LS_PRESETS = 'signal_presets';
const LS_THEME = 'signal_theme';
const LS_FINANCE = 'signal_finance_provider';
const LS_FONT = 'signal_font';
const LS_CASE = 'signal_case';
const LS_RECENTS = 'signal_recent_accounts';
const CORS_PROXY = 'https://sentry.tomaspalmeirim.workers.dev/?url=';

let customAccounts = [];      // manually added accounts
let loadedPresets = [];       // array of preset names currently loaded
let expandedPresets = new Set(); // which preset groups are expanded
let range = 1;
let lastScanResult = null;
let busy = false;
let logs = [];
let filters = { category: null };

// Get all accounts (presets + custom) for scanning
function getAllAccounts() {
  const all = [...customAccounts];
  const presets = getPresets();
  for (const name of loadedPresets) {
    const p = presets.find(p => p.name === name);
    if (p) all.push(...p.accounts);
  }
  return [...new Set(all)]; // dedupe
}

function hasAnyAccounts() {
  return customAccounts.length > 0 || loadedPresets.length > 0;
}

// --- DOM ---
const $ = id => document.getElementById(id);
const esc = s => { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; };

// --- Theme ---
function getTheme() { return localStorage.getItem(LS_THEME) || 'light'; }
function setTheme(t) {
  localStorage.setItem(LS_THEME, t);
  document.documentElement.setAttribute('data-theme', t);
}
function toggleTheme() { setTheme(getTheme() === 'dark' ? 'light' : 'dark'); }

// --- Presets ---
function getPresets() {
  const stored = localStorage.getItem(LS_PRESETS);
  if (!stored) {
    // Initialize with defaults on first load
    localStorage.setItem(LS_PRESETS, JSON.stringify(DEFAULT_PRESETS));
    return DEFAULT_PRESETS;
  }
  return JSON.parse(stored);
}
function savePresetsData(p) { localStorage.setItem(LS_PRESETS, JSON.stringify(p)); }
function loadPreset(name) {
  const preset = getPresets().find(p => p.name === name);
  if (!preset) return;
  
  // Toggle preset on/off
  if (loadedPresets.includes(name)) {
    loadedPresets = loadedPresets.filter(n => n !== name);
    expandedPresets.delete(name);
  } else {
    loadedPresets.push(name);
  }
  saveLoadedPresets();
  render();
}

function unloadPreset(name) {
  loadedPresets = loadedPresets.filter(n => n !== name);
  expandedPresets.delete(name);
  saveLoadedPresets();
  render();
}

function togglePresetExpand(name) {
  if (expandedPresets.has(name)) {
    expandedPresets.delete(name);
  } else {
    expandedPresets.add(name);
  }
  renderChips();
}
function deletePreset(name) {
  savePresetsData(getPresets().filter(p => p.name !== name));
  renderPresets();
  renderPresetList();
}
function renderPresets() {
  const el = $('presetsRow');
  const presets = getPresets();
  let h = '';
  presets.forEach(p => {
    const active = loadedPresets.includes(p.name) ? ' active' : '';
    h += `<button class="preset-btn${active}" onclick="loadPreset('${esc(p.name)}')">${esc(p.name)}</button>`;
  });
  h += `<button class="preset-manage" onclick="openPresetModal()">+</button>`;
  el.innerHTML = h;
}
let editingPresetName = null; // track if editing an existing preset

function openPresetModal() {
  editingPresetName = null;
  $('presetNameInput').value = '';
  $('presetAccountsInput').value = getAllAccounts().join(', ');
  renderPresetList();
  $('presetModal').classList.add('open');
  $('presetNameInput').focus();
}
function closePresetModal() {
  editingPresetName = null;
  $('presetModal').classList.remove('open');
}
function editPreset(name) {
  const preset = getPresets().find(p => p.name === name);
  if (!preset) return;
  editingPresetName = name;
  $('presetNameInput').value = preset.name;
  $('presetAccountsInput').value = preset.accounts.join(', ');
  $('presetNameInput').focus();
  renderPresetList();
}
function savePreset() {
  const name = $('presetNameInput').value.trim();
  const accountsStr = $('presetAccountsInput').value;
  const accts = accountsStr.split(',').map(a => a.trim().replace(/^@/, '').toLowerCase()).filter(a => a);
  if (!name || !accts.length) return;
  
  let presets = getPresets();
  if (editingPresetName) {
    // Update existing preset
    presets = presets.filter(p => p.name !== editingPresetName);
  }
  presets = presets.filter(p => p.name !== name);
  presets.push({ name, accounts: accts });
  savePresetsData(presets);
  
  // Update loaded presets if name changed
  if (editingPresetName && editingPresetName !== name && loadedPresets.includes(editingPresetName)) {
    loadedPresets = loadedPresets.map(n => n === editingPresetName ? name : n);
    saveLoadedPresets();
  }
  
  editingPresetName = null;
  renderPresets();
  renderPresetList();
  render();
  $('presetNameInput').value = '';
  $('presetAccountsInput').value = '';
}
function renderPresetList() {
  const el = $('presetList');
  const presets = getPresets();
  if (!presets.length) { el.innerHTML = '<p style="color:var(--text-muted);font-size:13px;margin-top:8px">No presets yet</p>'; return; }
  el.innerHTML = presets.map(p => {
    const isEditing = editingPresetName === p.name;
    return `
    <div class="preset-list-item${isEditing ? ' editing' : ''}">
      <span>${esc(p.name)}<small>${p.accounts.length} accounts</small></span>
      <div class="preset-list-actions">
        <button onclick="editPreset('${esc(p.name)}')">${isEditing ? 'Editing' : 'Edit'}</button>
        <button class="danger" onclick="deletePreset('${esc(p.name)}')">Delete</button>
      </div>
    </div>
  `}).join('');
}
// Only close modal if mousedown AND mouseup both happen on backdrop
let presetModalMouseDownTarget = null;
$('presetModal').addEventListener('mousedown', e => { presetModalMouseDownTarget = e.target; });
$('presetModal').addEventListener('click', e => {
  if (e.target === $('presetModal') && presetModalMouseDownTarget === $('presetModal')) closePresetModal();
  presetModalMouseDownTarget = null;
});
$('presetNameInput').addEventListener('keydown', e => { if (e.key === 'Enter') $('presetAccountsInput').focus(); });
$('presetAccountsInput').addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); savePreset(); } });

// --- Account Persistence ---
function saveAccounts() { localStorage.setItem(LS_ACCOUNTS, JSON.stringify(customAccounts)); }
function loadAccountsData() {
  const saved = localStorage.getItem(LS_ACCOUNTS);
  if (saved) customAccounts = JSON.parse(saved);
}
function saveLoadedPresets() { localStorage.setItem(LS_LOADED_PRESETS, JSON.stringify(loadedPresets)); }
function loadLoadedPresets() {
  const saved = localStorage.getItem(LS_LOADED_PRESETS);
  if (saved) loadedPresets = JSON.parse(saved);
}

// --- Recent Accounts ---
function getRecents() {
  return JSON.parse(localStorage.getItem(LS_RECENTS) || '[]');
}
function addToRecents(accounts) {
  let recents = getRecents();
  // Add new accounts to front, remove duplicates
  accounts.forEach(a => {
    recents = recents.filter(r => r !== a);
    recents.unshift(a);
  });
  // Keep only MAX_RECENTS
  recents = recents.slice(0, MAX_RECENTS);
  localStorage.setItem(LS_RECENTS, JSON.stringify(recents));
}

// ============================================================================
// API KEYS & SETTINGS - With validation
// ============================================================================

function getTwKey() { return localStorage.getItem(LS_TW) || ''; }
function getAnKey() { return localStorage.getItem(LS_AN) || ''; }

// Check if both keys exist and have reasonable format
function bothKeys() {
  const tw = getTwKey();
  const an = getAnKey();
  // Basic validation: keys should be non-empty and have reasonable length
  return tw.length >= 20 && an.length >= 20;
}

// Validate API key format (basic sanity check)
function validateApiKey(key, type) {
  if (!key || typeof key !== 'string') return false;
  key = key.trim();
  if (key.length < 20) return false;
  // Anthropic keys start with sk-ant-
  if (type === 'anthropic' && !key.startsWith('sk-ant-')) return false;
  return true;
}

function getFinanceProvider() { return localStorage.getItem(LS_FINANCE) || 'yahoo'; }
function getFont() { return localStorage.getItem(LS_FONT) || 'mono'; }
function setFont(f) {
  localStorage.setItem(LS_FONT, f);
  document.documentElement.setAttribute('data-font', f);
}
function getCase() { return localStorage.getItem(LS_CASE) || 'lower'; }
function setCase(c) {
  localStorage.setItem(LS_CASE, c);
  document.documentElement.setAttribute('data-case', c);
}
function getPrompt() { return localStorage.getItem(LS_PROMPT) || DEFAULT_PROMPT; }
function setPrompt(p) { localStorage.setItem(LS_PROMPT, p); }
function resetPrompt() { $('promptInput').value = DEFAULT_PROMPT; }

// Cache cleanup (called on init)
function cleanupCache() {
  // Clear old tweet cache entries (older than 2 hours)
  const now = Date.now();
  const twoHoursAgo = Math.floor(now / 3600000) - 2;
  for (const [key] of tweetCache) {
    const keyHour = parseInt(key.split(':')[2]);
    if (keyHour < twoHoursAgo) {
      tweetCache.delete(key);
    }
  }
}

function openModal() {
  $('twKeyInput').value = getTwKey();
  $('keyInput').value = getAnKey();
  $('financeProvider').value = getFinanceProvider();
  $('fontProvider').value = getFont();
  $('caseProvider').value = getCase();
  $('promptInput').value = getPrompt();
  $('modal').classList.add('open');
  $('clearKeyBtn').style.display = (getTwKey() || getAnKey()) ? '' : 'none';
  setTimeout(() => $('twKeyInput').focus(), 50);
}
function closeModal() { $('modal').classList.remove('open'); }
function saveKeys() {
  const tw = $('twKeyInput').value.trim();
  const an = $('keyInput').value.trim();
  const fp = $('financeProvider').value;
  const font = $('fontProvider').value;
  const textCase = $('caseProvider').value;
  const prompt = $('promptInput').value.trim();
  if (tw) localStorage.setItem(LS_TW, tw); else localStorage.removeItem(LS_TW);
  if (an) localStorage.setItem(LS_AN, an); else localStorage.removeItem(LS_AN);
  localStorage.setItem(LS_FINANCE, fp);
  setFont(font);
  setCase(textCase);
  setPrompt(prompt || DEFAULT_PROMPT);
  updateKeyBtn();
  closeModal();
}
function clearKeys() {
  localStorage.removeItem(LS_TW);
  localStorage.removeItem(LS_AN);
  $('twKeyInput').value = '';
  $('keyInput').value = '';
  updateKeyBtn();
  closeModal();
}
function updateKeyBtn() {
  const ok = bothKeys();
  $('keyBtn').classList.toggle('warn', !ok);
  $('keyBtn').textContent = 'Settings';
}
// Only close modal if mousedown AND mouseup both happen on backdrop
let modalMouseDownTarget = null;
$('modal').addEventListener('mousedown', e => { modalMouseDownTarget = e.target; });
$('modal').addEventListener('click', e => {
  if (e.target === $('modal') && modalMouseDownTarget === $('modal')) closeModal();
  modalMouseDownTarget = null;
});
$('twKeyInput').addEventListener('keydown', e => { if (e.key === 'Enter') $('keyInput').focus(); });
$('keyInput').addEventListener('keydown', e => { if (e.key === 'Enter') saveKeys(); });
updateKeyBtn();

// --- Accounts ---
function add(h) {
  const c = h.trim().replace(/^@/, '').toLowerCase();
  if (c && !customAccounts.includes(c)) customAccounts.push(c);
  $('acctInput').value = '';
  $('addBtn').classList.remove('vis');
  saveAccounts();
  render();
  $('acctInput').focus();
}
function rmCustom(h) {
  customAccounts = customAccounts.filter(a => a !== h);
  saveAccounts();
  render();
}

$('acctInput').addEventListener('input', function() {
  this.value = this.value.replace(/^@/, '');
  $('addBtn').classList.toggle('vis', this.value.trim().length > 0);
});
$('acctInput').addEventListener('keydown', e => {
  if (e.key === 'Enter' && $('acctInput').value.trim()) { e.preventDefault(); add($('acctInput').value); }
});
$('addBtn').addEventListener('click', () => { if ($('acctInput').value.trim()) add($('acctInput').value); });

// --- Render helpers ---
function render() { renderPresets(); renderSuggested(); renderRanges(); renderChips(); }

function renderSuggested() {
  const el = $('suggested');
  const recents = getRecents();
  if (!recents.length) { el.innerHTML = ''; return; }
  
  const allAccounts = getAllAccounts();
  el.innerHTML = '';
  
  recents.forEach(s => {
    const b = document.createElement('button');
    b.className = 'sug' + (allAccounts.includes(s) ? ' used' : '');
    b.textContent = s;
    if (!allAccounts.includes(s)) b.addEventListener('click', () => add(s));
    el.appendChild(b);
  });
}

function renderRanges() {
  const row = $('rangesRow');
  row.innerHTML = '';
  RANGES.forEach((r, i) => {
    const b = document.createElement('button');
    b.className = 'rng' + (range === i ? ' on' : '');
    b.textContent = r.label;
    b.addEventListener('click', () => { range = i; renderRanges(); });
    row.appendChild(b);
  });
  row.classList.toggle('mb', hasAnyAccounts());
}

function renderChips() {
  const el = $('chipsRow');
  el.innerHTML = '';
  el.classList.toggle('vis', hasAnyAccounts());
  
  const presets = getPresets();
  const COLLAPSE_THRESHOLD = 5;
  
  // Render each loaded preset as a group
  loadedPresets.forEach(name => {
    const preset = presets.find(p => p.name === name);
    if (!preset) return;
    
    const isExpanded = expandedPresets.has(name);
    const canCollapse = preset.accounts.length > COLLAPSE_THRESHOLD;
    
    if (!isExpanded) {
      // Collapsed - show summary
      const group = document.createElement('span');
      group.className = 'chip-group collapsed';
      group.innerHTML = `<button class="chip chip-summary" onclick="togglePresetExpand('${esc(name)}')">${esc(name)} <span class="chip-count">(${preset.accounts.length})</span></button><button class="chip-x" onclick="unloadPreset('${esc(name)}')">âœ•</button>`;
      el.appendChild(group);
    } else {
      // Expanded - show all accounts in this preset (sorted alphabetically)
      const group = document.createElement('span');
      group.className = 'chip-group expanded';
      let h = `<button class="chip chip-header" onclick="togglePresetExpand('${esc(name)}')">${esc(name)} âˆ’</button>`;
      [...preset.accounts].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase())).forEach(a => {
        h += `<span class="chip">@${esc(a)}</span>`;
      });
      h += `<button class="chip-x" onclick="unloadPreset('${esc(name)}')">âœ•</button>`;
      group.innerHTML = h;
      el.appendChild(group);
    }
  });
  
  // Render custom accounts
  customAccounts.forEach(a => {
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.innerHTML = `@${esc(a)}<span class="x" onclick="rmCustom('${esc(a)}')">âœ•</span>`;
    el.appendChild(chip);
  });
  
  // Clear all button
  if (loadedPresets.length > 0 || customAccounts.length > 0) {
    const clearBtn = document.createElement('button');
    clearBtn.className = 'clear-btn';
    clearBtn.textContent = 'Clear';
    clearBtn.addEventListener('click', clearAllAccounts);
    el.appendChild(clearBtn);
  }
  
  const btn = document.createElement('button');
  btn.className = 'scan-btn';
  btn.disabled = busy;
  btn.textContent = busy ? 'Scanning...' : 'Scan';
  btn.addEventListener('click', run);
  el.appendChild(btn);
}

function clearAllAccounts() {
  customAccounts = [];
  loadedPresets = [];
  expandedPresets.clear();
  saveAccounts();
  saveLoadedPresets();
  render();
}

function setLoading(v) {
  busy = v;
  $('dot').classList.toggle('loading', v);
  renderChips();
}
function setStatus(t, animate = false, showDownload = false) {
  const el = $('tweetCount');
  if (!t) { el.innerHTML = ''; return; }
  const dl = showDownload ? `<button class="dl-btn" onclick="downloadLastScan()">â†“ Download JSON</button>` : '';
  el.innerHTML = `<div class="tweet-count">${t}${animate ? '<span class="dots"></span>' : ''}${dl}</div>`;
}

// ============================================================================
// TWITTER API - Robust fetching with caching and intelligent retry
// ============================================================================

// In-memory cache for tweets (prevents re-fetching on analysis failures)
const tweetCache = new Map();

function getCacheKey(account, days) {
  // Cache key includes hour to allow reasonable freshness while preventing spam
  const hour = Math.floor(Date.now() / 3600000);
  return `${account}:${days}:${hour}`;
}

async function fetchTweetsWithRetry(account, days, maxRetries = 3) {
  const cacheKey = getCacheKey(account, days);
  
  // Return cached data if available (from this session)
  if (tweetCache.has(cacheKey)) {
    console.log(`[${account}] Using cached tweets`);
    return tweetCache.get(cacheKey);
  }
  
  const key = getTwKey();
  if (!key) throw new Error('No Twitter API key configured. Add it in Settings.');

  const cutoff = new Date(Date.now() - days * 86400000);
  console.log(`[${account}] Fetching tweets since ${cutoff.toISOString()} (${days} days)`);
  
  const allTweets = [];
  let cursor = null;
  let pages = 0;
  const MAX_PAGES = 5;
  let consecutiveErrors = 0;

  while (pages < MAX_PAGES) {
    const params = new URLSearchParams({ userName: account });
    if (cursor) params.set('cursor', cursor);

    const targetUrl = `https://api.twitterapi.io/twitter/user/last_tweets?${params}`;
    const fetchUrl = CORS_PROXY + encodeURIComponent(targetUrl);

    let res, data;
    let pageRetries = 0;
    
    while (pageRetries <= maxRetries) {
      try {
        res = await fetch(fetchUrl, {
          method: 'GET',
          headers: {
            'X-API-Key': key,
            'Accept': 'application/json',
          },
        });

        // Auth errors - fail immediately, no retry
        if (res.status === 401 || res.status === 403) {
          const body = await res.text().catch(() => '');
          throw new Error(`Twitter API auth error: ${body.slice(0, 100) || 'invalid key'}`);
        }
        
        // Rate limit - wait with backoff
        if (res.status === 429) {
          const waitMs = backoffDelay(pageRetries, 5000, 30000);
          console.log(`[${account}] Rate limited, waiting ${Math.ceil(waitMs/1000)}s...`);
          await new Promise(r => setTimeout(r, waitMs));
          pageRetries++;
          continue;
        }
        
        // Other HTTP errors
        if (!res.ok) {
          if (pageRetries < maxRetries) {
            await new Promise(r => setTimeout(r, backoffDelay(pageRetries, 1000, 10000)));
            pageRetries++;
            continue;
          }
          const body = await res.text().catch(() => '');
          throw new Error(`Twitter API error ${res.status}: ${body.slice(0, 100) || res.statusText}`);
        }

        // Parse response
        const text = await res.text();
        try {
          data = JSON.parse(text);
        } catch (e) {
          console.warn(`[${account}] Invalid JSON response, retrying...`);
          if (pageRetries < maxRetries) {
            pageRetries++;
            continue;
          }
          throw new Error('Invalid JSON from Twitter API');
        }
        
        break; // Success, exit retry loop
        
      } catch (e) {
        if (e.message.includes('auth error') || e.message.includes('No Twitter API')) {
          throw e; // Don't retry auth errors
        }
        if (pageRetries >= maxRetries) {
          throw e;
        }
        console.warn(`[${account}] Fetch error, retrying:`, e.message);
        await new Promise(r => setTimeout(r, backoffDelay(pageRetries, 1000, 10000)));
        pageRetries++;
      }
    }

    // Process response data
    const apiData = data.data || data;
    
    if (data.status === 'error' || (data.status !== 'success' && data.message)) {
      consecutiveErrors++;
      if (consecutiveErrors >= 2) {
        console.warn(`[${account}] Multiple consecutive errors, stopping`);
        break;
      }
      continue;
    }
    
    consecutiveErrors = 0; // Reset on success

    const tweets = apiData.tweets || [];
    if (!tweets.length) {
      console.log(`[${account}] No more tweets`);
      break;
    }

    let hitCutoff = false;
    for (const tw of tweets) {
      const created = new Date(tw.createdAt);
      if (created < cutoff) { hitCutoff = true; break; }
      allTweets.push(tw);
    }

    if (hitCutoff) break;
    if (!apiData.has_next_page || !apiData.next_cursor) break;
    cursor = apiData.next_cursor;
    pages++;
    
    // Small delay between pagination
    await new Promise(r => setTimeout(r, 100));
  }

  // Cache the results
  if (allTweets.length > 0) {
    tweetCache.set(cacheKey, allTweets);
    console.log(`[${account}] Cached ${allTweets.length} tweets`);
  }

  return allTweets;
}

// Legacy alias for compatibility
async function fetchTweets(account, days) {
  return fetchTweetsWithRetry(account, days);
}

// ============================================================================
// TEXT SANITIZATION & JSON PARSING - Bulletproof handling
// ============================================================================

// Remove invalid Unicode (orphan surrogates) that break JSON
function sanitizeText(str) {
  if (!str) return '';
  if (typeof str !== 'string') return String(str);
  
  // Remove lone surrogates (characters in range U+D800 to U+DFFF that aren't properly paired)
  // Also remove other problematic characters
  return str
    .replace(/[\uD800-\uDBFF](?![\uDC00-\uDFFF])/g, '') // orphan high surrogates
    .replace(/(?<![\uD800-\uDBFF])[\uDC00-\uDFFF]/g, '') // orphan low surrogates
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // control characters
    .replace(/\uFFFD/g, ''); // replacement character
}

// Safe JSON parsing with multiple fallbacks
function safeParseSignals(text) {
  if (!text) return [];
  
  // Clean the text
  let clean = text
    .replace(/```json\s*/gi, '')
    .replace(/```\s*/g, '')
    .trim();
  
  // Try to extract JSON array
  const arrayMatch = clean.match(/\[[\s\S]*\]/);
  if (!arrayMatch) {
    console.warn('No JSON array found in response');
    return [];
  }
  
  let jsonStr = arrayMatch[0];
  
  // Attempt 1: Direct parse
  try {
    const result = JSON.parse(jsonStr);
    if (Array.isArray(result)) return result;
  } catch (e) {
    console.warn('Direct JSON parse failed, attempting fixes...');
  }
  
  // Attempt 2: Fix common issues
  try {
    // Fix trailing commas
    jsonStr = jsonStr.replace(/,\s*]/g, ']').replace(/,\s*}/g, '}');
    // Fix unescaped newlines in strings
    jsonStr = jsonStr.replace(/([^\\])\\n(?=")/g, '$1\\\\n');
    const result = JSON.parse(jsonStr);
    if (Array.isArray(result)) return result;
  } catch (e) {
    console.warn('Fixed JSON parse failed:', e.message);
  }
  
  // Attempt 3: Sanitize and try again
  try {
    jsonStr = sanitizeText(jsonStr);
    const result = JSON.parse(jsonStr);
    if (Array.isArray(result)) return result;
  } catch (e) {
    console.error('All JSON parse attempts failed:', e.message);
  }
  
  return [];
}

function formatTweetForAnalysis(tw) {
  const date = new Date(tw.createdAt).toISOString().slice(0, 16).replace('T', ' ');
  const engagement = `${tw.likeCount || 0}â™¥ ${tw.retweetCount || 0}â†» ${tw.viewCount || 0}ðŸ‘`;
  const url = tw.url || `https://x.com/i/status/${tw.id}`;
  let text = sanitizeText(tw.text || '');

  // collect external URLs (exclude twitter/x.com links)
  const externalLinks = [];
  if (tw.entities?.urls) {
    for (const u of tw.entities.urls) {
      if (u.url && u.expanded_url) {
        const expandedUrl = sanitizeText(u.expanded_url);
        text = text.replace(u.url, expandedUrl);
        // filter out twitter/x.com internal links
        if (!expandedUrl.match(/^https?:\/\/(twitter\.com|x\.com|t\.co)\//)) {
          externalLinks.push(expandedUrl);
        }
      }
    }
  }

  const parts = [`[${date}] ${text}`, `engagement: ${engagement}`, `tweet_url: ${url}`];
  if (externalLinks.length) parts.push(`external_links: ${externalLinks.join(', ')}`);
  if (tw.isReply) parts.push(`(reply to @${tw.inReplyToUsername || 'unknown'})`);
  if (tw.quoted_tweet) parts.push(`(quoting: "${tw.quoted_tweet.text?.slice(0, 120) || ''}")`);

  return parts.join('\n');
}

// ============================================================================
// ROBUST API LAYER - Bulletproof retry logic with exponential backoff + jitter
// ============================================================================

const API_CONFIG = {
  anthropic: {
    baseUrl: 'https://api.anthropic.com/v1/messages',
    maxRetries: 5,
    baseDelay: 2000,
    maxDelay: 120000, // 2 minutes max wait
    jitterFactor: 0.3,
  }
};

// Sleep with exponential backoff + jitter (prevents thundering herd)
function backoffDelay(attempt, baseDelay = 2000, maxDelay = 60000, jitter = 0.3) {
  const exponentialDelay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
  const jitterAmount = exponentialDelay * jitter * Math.random();
  return exponentialDelay + jitterAmount;
}

// Update status safely
function updateStatus(msg, animate = false) {
  const el = document.getElementById('tweetCount');
  if (!el) return;
  if (!msg) { el.innerHTML = ''; return; }
  el.innerHTML = `<div class="tweet-count">${msg}${animate ? '<span class="dots"></span>' : ''}</div>`;
}

// Categorize errors for appropriate handling
function categorizeError(error, status) {
  if (status === 429 || status === 529) return 'rate_limit';
  if (error?.type === 'overloaded_error') return 'overloaded';
  if (error?.type === 'rate_limit_error') return 'rate_limit';
  if (error?.message?.includes('quota')) return 'quota';
  if (error?.message?.includes('rate')) return 'rate_limit';
  if (error?.message?.includes('limit')) return 'rate_limit';
  if (error?.message?.includes('prompt is too long')) return 'input_too_large';
  if (error?.type === 'not_found_error') return 'model_not_found';
  if (error?.type === 'authentication_error') return 'auth_error';
  if (error?.type === 'invalid_request_error') return 'invalid_request';
  return 'unknown';
}

// Robust Anthropic API call with intelligent retry
async function anthropicCall(body, maxRetries = API_CONFIG.anthropic.maxRetries) {
  const key = getAnKey();
  if (!key) throw new Error('No Anthropic API key configured. Add it in Settings.');
  
  let lastError = null;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const res = await fetch(API_CONFIG.anthropic.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': key,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true',
        },
        body: JSON.stringify(body),
      });
      
      const data = await res.json();
      
      // Success
      if (!data.error) {
        if (attempt > 0) console.log(`âœ“ Anthropic succeeded on attempt ${attempt + 1}`);
        return data;
      }
      
      // Error handling
      const errorType = categorizeError(data.error, res.status);
      console.warn(`Anthropic error (attempt ${attempt + 1}/${maxRetries + 1}):`, errorType, data.error?.message);
      
      // Non-retryable errors - fail immediately
      if (['input_too_large', 'model_not_found', 'auth_error', 'invalid_request'].includes(errorType)) {
        const messages = {
          input_too_large: 'Input too large. Try fewer accounts or a shorter time range.',
          model_not_found: 'Model not available. Your API key may not have access to this model.',
          auth_error: 'Invalid API key. Please check your Anthropic API key in Settings.',
          invalid_request: data.error?.message || 'Invalid request to Anthropic API.',
        };
        throw new Error(messages[errorType] || data.error?.message);
      }
      
      // Retryable errors - wait with backoff
      if (['rate_limit', 'overloaded', 'quota'].includes(errorType)) {
        if (attempt >= maxRetries) {
          throw new Error(`API rate limited after ${maxRetries + 1} attempts. Please wait a few minutes and try again.`);
        }
        
        // Longer waits for quota/rate limit errors
        const baseWait = errorType === 'quota' ? 45000 : 15000;
        const waitMs = backoffDelay(attempt, baseWait, API_CONFIG.anthropic.maxDelay);
        const waitSecs = Math.ceil(waitMs / 1000);
        
        updateStatus(`Rate limited Â· Retry ${attempt + 2}/${maxRetries + 1} in ${waitSecs}s`, true);
        console.log(`Waiting ${waitSecs}s before retry...`);
        await new Promise(r => setTimeout(r, waitMs));
        continue;
      }
      
      // Unknown error - store and retry with shorter backoff
      lastError = data.error;
      if (attempt < maxRetries) {
        const waitMs = backoffDelay(attempt, 2000, 30000);
        await new Promise(r => setTimeout(r, waitMs));
      }
      
    } catch (e) {
      // Network errors, JSON parse errors, etc.
      if (e.message.includes('No Anthropic') || e.message.includes('Invalid API') || 
          e.message.includes('Input too large') || e.message.includes('Model not available')) {
        throw e; // Don't retry these
      }
      
      lastError = e;
      console.warn(`Anthropic fetch error (attempt ${attempt + 1}):`, e.message);
      
      if (attempt < maxRetries) {
        const waitMs = backoffDelay(attempt, 3000, 30000);
        await new Promise(r => setTimeout(r, waitMs));
      }
    }
  }
  
  throw new Error(lastError?.message || 'Failed to connect to Anthropic API after multiple attempts.');
}

function extractText(content) {
  if (!content) return '';
  if (typeof content === 'string') return content;
  if (!Array.isArray(content)) return '';
  return content.filter(b => b.type === 'text' && b.text).map(b => b.text).join('\n');
}

// ============================================================================
// SCAN ENGINE - Orchestrates the complete scan workflow
// ============================================================================

// Scan state for abort support
let currentScanAbort = null;

function abortCurrentScan() {
  if (currentScanAbort) {
    currentScanAbort.abort();
    currentScanAbort = null;
  }
}

// Fetch all accounts' tweets with progress tracking
async function fetchAllTweets(accounts, days, onProgress) {
  const BATCH_SIZE = 2; // Parallel fetch count
  const accountTweets = [];
  
  for (let i = 0; i < accounts.length; i += BATCH_SIZE) {
    const batch = accounts.slice(i, i + BATCH_SIZE);
    const progress = Math.round((i / accounts.length) * 100);
    onProgress?.(`Fetching ${i + 1}-${Math.min(i + batch.length, accounts.length)} of ${accounts.length}`);
    
    const results = await Promise.all(batch.map(async (account) => {
      try {
        const tweets = await fetchTweetsWithRetry(account, days);
        return { account, tweets, error: null };
      } catch (e) {
        console.warn(`[${account}] Fetch failed:`, e.message);
        return { account, tweets: [], error: e.message };
      }
    }));
    
    accountTweets.push(...results);
    
    // Small delay between batches (prevent rate limiting)
    if (i + BATCH_SIZE < accounts.length) {
      await new Promise(r => setTimeout(r, 150));
    }
  }
  
  return accountTweets;
}

// Analyze tweets with intelligent batching
async function analyzeWithBatching(accountData, totalTweets, onProgress) {
  const prompt = getPrompt();
  const MAX_BATCH_CHARS = 640000; // ~160k tokens
  const promptChars = prompt.length;
  
  // Pre-calculate batches for accurate progress
  const batches = [];
  let currentBatch = [];
  let currentSize = promptChars;
  
  for (const a of accountData) {
    const header = `=== @${a.account} (${a.tweets.length} tweets) ===`;
    const body = a.tweets.map(formatTweetForAnalysis).join('\n---\n');
    const accountText = `${header}\n${body}`;
    const accountSize = accountText.length + 20;
    
    if (currentBatch.length > 0 && currentSize + accountSize > MAX_BATCH_CHARS) {
      batches.push(currentBatch);
      currentBatch = [];
      currentSize = promptChars;
    }
    
    currentBatch.push({ account: a.account, text: accountText, size: accountSize });
    currentSize += accountSize;
  }
  if (currentBatch.length > 0) batches.push(currentBatch);
  
  console.log(`Analysis batches: ${batches.length} (${accountData.length} accounts, ~${Math.round(currentSize/1000)}k chars)`);
  
  // Process batches
  const allSignals = [];
  
  for (let i = 0; i < batches.length; i++) {
    const batch = batches[i];
    const batchNum = i + 1;
    
    if (batches.length > 1) {
      onProgress?.(`Analyzing batch ${batchNum}/${batches.length}`);
    } else {
      onProgress?.(`${totalTweets} tweets fetched Â· Analyzing`);
    }
    
    const batchContent = sanitizeText(`${prompt}\n\n${batch.map(b => b.text).join('\n\n======\n\n')}`);
    
    try {
      const data = await anthropicCall({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 16384,
        messages: [{ role: 'user', content: batchContent }],
      }, 5);
      
      const txt = extractText(data.content);
      logs.push({ a: `_batch${batchNum}`, len: txt.length, pre: txt.slice(0, 400) });
      
      // Parse signals from response using safe parser
      const batchSignals = safeParseSignals(txt);
      if (batchSignals.length > 0) {
        allSignals.push(...batchSignals);
        console.log(`Batch ${batchNum}: ${batchSignals.length} signals parsed`);
      } else {
        console.warn(`Batch ${batchNum}: No signals extracted`);
        logs.push({ a: `_parse_warn_${batchNum}`, len: 0, pre: 'No signals extracted from response' });
      }
      
      // Delay between batch API calls (rate limit protection)
      if (i < batches.length - 1) {
        await new Promise(r => setTimeout(r, 1500));
      }
      
    } catch (e) {
      console.error(`Batch ${batchNum} analysis error:`, e);
      throw e; // Re-throw to stop the scan
    }
  }
  
  return allSignals;
}

// --- Main flow ---
let lastRunTime = 0;
async function run() {
  // Debounce - prevent rapid repeated calls
  const now = Date.now();
  if (now - lastRunTime < 1000) return;
  lastRunTime = now;
  
  const accounts = getAllAccounts();
  if (!accounts.length || busy) return;
  if (!bothKeys()) { openModal(); return; }

  // Setup abort controller for this scan
  abortCurrentScan();
  currentScanAbort = new AbortController();

  setLoading(true);
  $('notices').innerHTML = '';
  $('tweetCount').innerHTML = '';
  $('tickerBar').innerHTML = '';
  $('scanActions').innerHTML = '';
  $('filterBar').innerHTML = '';
  $('results').innerHTML = '';
  $('debugSection').innerHTML = '';
  logs = [];
  
  // Save custom accounts to recents
  if (customAccounts.length) {
    addToRecents(customAccounts);
    renderSuggested();
  }

  const days = RANGES[range].days;

  try {
    // Step 1: Fetch tweets
    const accountTweets = await fetchAllTweets(accounts, days, (msg) => setStatus(msg, true));

    // Tally results
    const totalTweets = accountTweets.reduce((s, a) => s + a.tweets.length, 0);
    const fails = accountTweets.filter(a => a.error);
    const empties = accountTweets.filter(a => !a.error && !a.tweets.length);

    // Build debug logs
    for (const a of accountTweets) {
      logs.push({
        a: a.account,
        len: a.tweets.length,
        pre: a.error
          ? `ERROR: ${a.error}`
          : a.tweets.slice(0, 3).map(t => t.text?.slice(0, 100)).join(' | ') || '(no tweets in range)',
      });
    }

    // Handle no tweets case
    if (totalTweets === 0) {
      let msg = 'no tweets found for this time range';
      if (fails.length) msg += ` â€” errors: ${fails.map(f => `${f.account} (${f.error})`).join(', ')}`;
      $('notices').innerHTML = `<div class="notice err">${esc(msg)}</div>`;
      setLoading(false); setStatus(''); renderDebug(); return;
    }

    // Show warnings for partial failures
    const parts = [];
    if (fails.length) parts.push(`<span style="color:var(--red)">errors: ${esc(fails.map(f => f.account).join(', '))}</span>`);
    if (empties.length) parts.push(`<span style="color:var(--amber)">No posts: ${esc(empties.map(e => e.account).join(', '))}</span>`);
    if (parts.length) $('notices').innerHTML = `<div class="notice warn">${parts.join(' Â· ')}</div>`;

    // Step 2: Analyze with Claude
    const accountData = accountTweets.filter(a => a.tweets.length);
    const signals = await analyzeWithBatching(accountData, totalTweets, (msg) => setStatus(msg, true));

    // Store scan result
    lastScanResult = {
      date: new Date().toISOString(),
      range: RANGES[range].label,
      days: RANGES[range].days,
      accounts: [...accounts],
      totalTweets,
      signals,
      rawTweets: accountTweets.map(a => ({ account: a.account, tweets: a.tweets })),
    };
    saveScan(lastScanResult);

    // Update status to final count with full info
    const d = new Date();
    const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    setStatus(`${dateStr} Â· <span class="hide-mobile">${accounts.length} accounts Â· ${totalTweets} tweets Â· </span>${signals.length} signals`, false, true);

    renderTickers(signals);
    renderSignals(signals);
    renderDebug();
    
  } catch (e) {
    if (e.name === 'AbortError') {
      setStatus('Scan cancelled');
    } else {
      setStatus(''); // Clear analyzing status
      $('notices').innerHTML = `<div class="notice err">${esc(e.message)}</div>`;
    }
    renderDebug();
  } finally {
    setLoading(false);
    currentScanAbort = null;
  }
}

// --- Scan Storage ---
// Create a lightweight version for storage (no full tweet content)
function createStorableScan(scan) {
  // Only store essential tweet metadata for tooltips, not full tweet objects
  const tweetMeta = {};
  if (scan.rawTweets) {
    scan.rawTweets.forEach(a => {
      (a.tweets || []).forEach(tw => {
        const url = tw.url || `https://x.com/i/status/${tw.id}`;
        tweetMeta[url] = {
          text: (tw.text || '').slice(0, 500), // Truncate long tweets
          author: a.account,
          time: tw.createdAt
        };
      });
    });
  }
  
  return {
    date: scan.date,
    range: scan.range,
    days: scan.days,
    accounts: scan.accounts,
    totalTweets: scan.totalTweets,
    signals: scan.signals,
    tweetMeta // Much smaller than rawTweets
  };
}

function saveScan(scan) {
  try {
    const storable = createStorableScan(scan);
    
    // Save current scan
    localStorage.setItem(LS_CURRENT, JSON.stringify(storable));
    
    // Update history (keep only last 5 to save space)
    const history = JSON.parse(localStorage.getItem(LS_SCANS) || '[]');
    // Only store minimal info in history (no tweetMeta)
    const historyEntry = {
      date: scan.date,
      range: scan.range,
      accounts: scan.accounts.length,
      totalTweets: scan.totalTweets,
      signalCount: scan.signals.length
    };
    history.unshift(historyEntry);
    if (history.length > 5) history.pop();
    localStorage.setItem(LS_SCANS, JSON.stringify(history));
  } catch (e) {
    console.warn('Failed to save scan to localStorage:', e.message);
    // Clear old data and try again
    try {
      localStorage.removeItem(LS_SCANS);
      localStorage.setItem(LS_CURRENT, JSON.stringify(createStorableScan(scan)));
    } catch (e2) {
      console.error('Storage quota exceeded, clearing storage');
      localStorage.removeItem(LS_CURRENT);
      localStorage.removeItem(LS_SCANS);
    }
  }
}

function loadCurrentScan() {
  const saved = localStorage.getItem(LS_CURRENT);
  if (!saved) return null;
  try { return JSON.parse(saved); } catch { return null; }
}

function getScanHistory() {
  return JSON.parse(localStorage.getItem(LS_SCANS) || '[]');
}

function downloadLastScan() {
  if (!lastScanResult) return;
  
  // Build tweet lookup for original text
  const tweetText = {};
  if (lastScanResult.rawTweets) {
    lastScanResult.rawTweets.forEach(a => {
      (a.tweets || []).forEach(tw => {
        const url = tw.url || `https://x.com/i/status/${tw.id}`;
        tweetText[url] = tw.text || '';
      });
    });
  } else if (lastScanResult.tweetMeta) {
    Object.entries(lastScanResult.tweetMeta).forEach(([url, meta]) => {
      tweetText[url] = meta.text || '';
    });
  }
  
  // Create clean export
  const cleanExport = {
    date: lastScanResult.date,
    range: lastScanResult.range,
    accounts: lastScanResult.accounts,
    signals: lastScanResult.signals.map(s => ({
      title: s.title,
      summary: s.summary,
      category: s.category,
      tickers: (s.tickers || []).map(t => ({
        symbol: t.symbol,
        action: t.action
      })),
      source: s.source,
      tweet: tweetText[s.tweet_url] || '',
      links: s.links || []
    }))
  };
  
  const date = new Date(lastScanResult.date).toISOString().slice(0, 16).replace('T', '-').replace(':', '');
  const blob = new Blob([JSON.stringify(cleanExport, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `sentry-${date}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// --- Renderers ---
function tickerUrl(sym) {
  const s = sym.replace(/^\$/, '').toUpperCase();
  if (getFinanceProvider() === 'google') {
    // Google Finance needs exchange, try to infer from suffix
    if (s.endsWith('.TW')) return `https://www.google.com/finance/quote/${s.replace('.TW', '')}:TPE?window=6M`;
    if (s.endsWith('.HK')) return `https://www.google.com/finance/quote/${s.replace('.HK', '')}:HKG?window=6M`;
    if (s.endsWith('.T')) return `https://www.google.com/finance/quote/${s.replace('.T', '')}:TYO?window=6M`;
    if (s.endsWith('.KS')) return `https://www.google.com/finance/quote/${s.replace('.KS', '')}:KRX?window=6M`;
    return `https://www.google.com/finance/quote/${s}?window=6M`;
  }
  return `https://finance.yahoo.com/quote/${encodeURIComponent(s)}`;
}

function renderTickers(signals) {
  const map = {};
  signals.forEach(r => (r.tickers || []).forEach(t => {
    const k = (t.symbol || '').toUpperCase();
    if (!k) return;
    if (!map[k]) map[k] = { s: k, acts: new Set(), n: 0 };
    map[k].acts.add(t.action); map[k].n++;
  }));
  const list = Object.values(map).sort((a, b) => b.n - a.n);
  const el = $('tickerBar');
  if (!list.length) { el.innerHTML = ''; el.className = ''; return; }
  el.className = 'ticker-bar';
  el.innerHTML = list.map(t => {
    // If both buy and sell, show "mixed"
    const hasBuy = t.acts.has('buy');
    const hasSell = t.acts.has('sell');
    const pa = (hasBuy && hasSell) ? 'mixed' : ['sell', 'buy', 'hold', 'watch'].find(a => t.acts.has(a)) || 'watch';
    const url = tickerUrl(t.s);
    return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="ticker-item" style="color:${ACT_C[pa]};background:${ACT_BG[pa]}">${esc(t.s)}${t.n > 1 ? `<span class="ticker-cnt">Ã—${t.n}</span>` : ''}</a>`;
  }).join('');
}

function renderScanActions() {
  $('scanActions').innerHTML = '';
}

function renderSignals(signals) {
  const el = $('results');
  filters = { category: null }; // reset filters
  if (!signals.length) { el.innerHTML = '<div class="empty-state">No signals extracted</div>'; renderScanActions(); renderFilters(); $('footer').innerHTML = ''; return; }
  
  // Build tweet URL to info map from rawTweets or tweetMeta
  const tweetMap = {};
  if (lastScanResult?.rawTweets) {
    // Full data available (current session)
    lastScanResult.rawTweets.forEach(a => {
      (a.tweets || []).forEach(tw => {
        const url = tw.url || `https://x.com/i/status/${tw.id}`;
        const date = tw.createdAt ? new Date(tw.createdAt) : null;
        const timeStr = date ? date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
        tweetMap[url] = {
          text: tw.text || '',
          author: tw.author?.userName || a.account || '',
          time: timeStr
        };
      });
    });
  } else if (lastScanResult?.tweetMeta) {
    // Loaded from storage (lighter format)
    Object.entries(lastScanResult.tweetMeta).forEach(([url, meta]) => {
      const date = meta.time ? new Date(meta.time) : null;
      const timeStr = date ? date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
      tweetMap[url] = {
        text: meta.text || '',
        author: meta.author || '',
        time: timeStr
      };
    });
  }
  
  let h = '';
  signals.forEach((item, i) => {
    const cat = normCat(item.category);
    const tweetInfo = item.tweet_url ? (tweetMap[item.tweet_url] || {}) : {};
    const source = (item.source || '').replace(/^@/, '');
    const time = tweetInfo.time || '';
    
    const tickers = (item.tickers && item.tickers.length)
      ? item.tickers.map(t => {
          const url = tickerUrl(t.symbol || '');
          return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="ticker-tag" style="color:${ACT_C[t.action] || 'var(--text-muted)'};background:${ACT_BG[t.action] || 'var(--text-10)'}">${esc(t.symbol)}</a>`;
        }).join('')
      : '';
    
    const extLinks = (item.links && item.links.length)
      ? item.links.map(l => {
          try {
            const hostname = new URL(l).hostname.replace('www.','');
            return `<a href="${esc(l)}" target="_blank" rel="noopener noreferrer" class="ext-link">${esc(hostname)}</a>`;
          } catch { return ''; }
        }).filter(Boolean).join(' ')
      : '';
    
    const sourceLink = item.tweet_url 
      ? `<a href="${esc(item.tweet_url)}" target="_blank" rel="noopener noreferrer" data-tweet="${esc(tweetInfo.text || '')}" data-author="${esc(source)}" data-time="${esc(time)}">@${esc(source)}</a>`
      : `@${esc(source)}`;
    
    const seePost = item.tweet_url
      ? `<a href="${esc(item.tweet_url)}" target="_blank" rel="noopener noreferrer" class="see-post" data-tweet="${esc(tweetInfo.text || '')}" data-author="${esc(source)}" data-time="${esc(time)}"><span class="text">See post</span><span class="arrow">â†—</span></a>`
      : '';
    
    h += `<div class="signal" data-category="${esc(cat || '')}">
      <div class="sig-top"><span>${sourceLink}${time ? ` Â· ${time}` : ''}${cat ? ` Â· <span class="sig-cat">${esc(cat)}</span>` : ''}</span>${seePost}</div>
      ${tickers ? `<div class="sig-tickers">${tickers}</div>` : ''}
      <div class="sig-title">${esc(item.title || '')}</div>
      <div class="sig-summary">${esc(item.summary || '')}</div>
      ${extLinks ? `<div class="sig-links">${extLinks}</div>` : ''}
    </div>`;
  });
  el.innerHTML = h;
  renderScanActions();
  renderFilters();
  $('footer').innerHTML = 'Not financial advice';
  setupTweetTooltips();
  el.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function setupTweetTooltips() {
  const tooltip = $('tweetTooltip');
  document.querySelectorAll('.see-post[data-tweet]').forEach(link => {
    link.addEventListener('mouseenter', e => {
      const text = link.dataset.tweet;
      if (!text) return;
      const author = link.dataset.author || '';
      const time = link.dataset.time || '';
      const header = (author || time) ? `<div style="opacity:.7;margin-bottom:8px">@${esc(author)} Â· ${esc(time)}</div>` : '';
      tooltip.innerHTML = header + esc(text);
      tooltip.classList.add('vis');
    });
    link.addEventListener('mousemove', e => {
      const x = e.clientX + 12;
      const y = e.clientY + 12;
      // Keep tooltip in viewport
      const rect = tooltip.getBoundingClientRect();
      const maxX = window.innerWidth - rect.width - 20;
      const maxY = window.innerHeight - rect.height - 20;
      tooltip.style.left = Math.min(x, maxX) + 'px';
      tooltip.style.top = Math.min(y, maxY) + 'px';
    });
    link.addEventListener('mouseleave', () => {
      tooltip.classList.remove('vis');
    });
  });
}

function renderDebug() {
  const el = $('debugSection');
  if (!logs.length) { el.innerHTML = ''; return; }
  el.innerHTML = `<div class="debug-section">
    <button class="debug-toggle" id="debugToggle">â–¸ Debug</button>
    <div class="debug-content" id="debugContent">
      ${logs.map(l => `<div class="debug-entry"><span style="color:var(--text-muted)">@${esc(l.a)}</span> â€” ${l.len} ${l.a === '_analysis' ? 'chars' : 'tweets'}<div style="color:var(--text);margin-top:2px">${esc(l.pre)}</div></div>`).join('')}
    </div>
  </div>`;
  $('debugToggle').addEventListener('click', function() {
    const c = $('debugContent');
    const open = c.classList.toggle('open');
    this.textContent = (open ? 'â–¾' : 'â–¸') + ' Debug';
  });
}

// --- Filters ---
function setFilter(type, value) {
  filters[type] = filters[type] === value ? null : value;
  applyFilters();
  renderFilters();
}

function applyFilters() {
  const rows = document.querySelectorAll('#results .signal');
  rows.forEach(row => {
    const cat = row.dataset.category;
    const catMatch = !filters.category || cat === filters.category;
    row.classList.toggle('hidden', !catMatch);
  });
}

function renderFilters() {
  const el = $('filterBar');
  if (!lastScanResult || !lastScanResult.signals.length) { el.innerHTML = ''; return; }
  
  let h = '<div class="filter-bar">';
  CATEGORIES.forEach(c => {
    const on = filters.category === c ? ' on' : '';
    h += `<button class="rng${on}" onclick="setFilter('category','${c}')">${c}</button>`;
  });
  h += '</div>';
  el.innerHTML = h;
}

// ============================================================================
// INITIALIZATION
// ============================================================================

// Initialize app
(function init() {
  // Apply settings
  setTheme(getTheme());
  setFont(getFont());
  setCase(getCase());
  
  // Load user data
  loadAccountsData();
  loadLoadedPresets();
  
  // Cleanup old cache entries
  cleanupCache();
  
  // Render UI
  render();

  // Load previous scan on refresh
  const savedScan = loadCurrentScan();
  if (savedScan) {
    lastScanResult = savedScan;
    const d = new Date(savedScan.date);
    const dateStr = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    setStatus(`${dateStr} Â· <span class="hide-mobile">${savedScan.accounts.length} accounts Â· ${savedScan.totalTweets} tweets Â· </span>${savedScan.signals.length} signals`, false, true);
    renderTickers(savedScan.signals);
    renderSignals(savedScan.signals);
  }
  
  console.log('âœ“ Sentry initialized');
})();
</script>
</body>
</html>